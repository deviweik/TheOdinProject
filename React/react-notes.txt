Library vs Framework
  Inversion of control
    Library - you are in charge of the flow of the application, you choose 
    when and where to call the library.

    Framework - framework is in charge of the flow. It tells you where you 
    can plug in your own code, but it decides when to call this code.

  Opinionated
    The degree of freedom a library or framework gives the developer 
    dictates how "opinionated" it is. 

    More freedom = less opinionated

Vite 
  Used to quick start React projects
  
  Minimum steps required to configure your own project and development 
  environment:
    - Package Management (NPM, Yarn)
    - Module Bundling (Webpack, Parcel)
    - Compilation (Babel)
    - React itself 

    Vite can do most of this with a single terminal command
      npm create vite@latest my-first-react-app -- --template react

Default React Project Directory
  /public - static assests, i.e. images, icons, information files 

  /src - code that runs the app
    main.jsx - entry point of the application 
  
Components - break UI down into independent reusable chunks
  Components are javascript functions that return jsx (markup/js)

  Example: 
    function Greeting() {
      return <h1>&quot;Hello, World!&quot;</h1>;
    }

    export default Greeting;

  Components need to be exported (see example above)
    Make sure to capitalize!

  After being exported, Components can be imported to other React files
    Example from main.jsx:
      import Greeting from "./Greeting.jsx";

      ReactDOM.createRoot(document.getElementById("root")).render(
        <React.StrictMode>
          <Greeting />
        </React.StrictMode>,
      );
  
JSX - syntax extension that allows HTML-like markup inside a js file
  compiles down to plain javascript objects 

  JSX allows React to separate concerns by containing both rendering logic 
  and content in the same place (a component).

  There are other ways to write components but most devs prefer JSX for 
  it's conciseness. Most codebases use it 

  Rules of JSX:
    1. Return a single root element.
      You can return more than one element by wrapping them in a <div> or 
      by using a React fragment
        Example:
          return (
            <>
              HTML to return
            <>
          );
          // Could replace <></> with <div></div>

        *Note: Using a fragment will be invisible in the DOM, so the 
        elements within the fragment will be registered as their own 
        elements
          So this way the elements of the component are direct children of 
          the container.

          Using a div makes the div the direct child of the container, 
          while the individual elements are just children of the div

    2. Close all Tags.
      In HTML, many tags are self-closing and self-wrapping.
      
      In JSX however, we must explicitly close and wrap these tags.
        Examples:
          <input> would become <input />
          <li> would become <li></li>

    3. camelCase Most things.
      JSX turns to javascript, and attributes of elements become keys of 
      js objects

      For this reason, cannot use dashes or reserved words like 'class'
        Need to use className="class" instead
          Example:
            function App() {
              return (
              <div className="container">
                <svg>
                  <circle cx="25" cy="75" r="20" stroke="green" strokeWidth="2" />
                </svg>
              </div>
              );
            }
    
  Using Javascript within JSX
    Attributes can be passed as strings by enclosing in double or single 
    quotes

    Can also pass variables by enclosing in curly braces: {variableName}

    All javascript in JSX is contained within curly braces 
      You can also call functions
        Example: 
          const today = new Date();

          function formatDate(date) {
            return new Intl.DateTimeFormat(
              'en-US',
              { weekday: 'long' }
            ).format(date);
          }

          export default function TodoList() {
            return (
              <h1>To Do List for {formatDate(today)}</h1>
            );
          }
    
    Objects in JS are also denoted by enclosing in curly braces, so in JSX 
    you need to enclose in double curly braces if you want to define an 
    object 
      Really just an object inside JSX curlies
        Can also be written as so to make it easier to read:
          <ul style={
            {
              backgroundColor: 'black',
              color: 'pink'
            }
          }> 

      Example: 
        person={{ name: "Hedy Lamarr", inventions: 5 }};

      Actual Use Case: 
        export default function TodoList() {
          return (
            <ul style={{
              backgroundColor: 'black',
              color: 'pink'
            }}>
              <li>Improve the videophone</li>
              <li>Prepare aeronautics lectures</li>
              <li>Work on the alcohol-fuelled engine</li>
            </ul>
          );
        }

    You can create objects that contain not only content for your 
    components but the style as well
      Example: 
        const person = {
          name: 'Gregorio Y. Zara',
          theme: {
            backgroundColor: 'black',
            color: 'pink'
          }
        };

        export default function TodoList() {
          return (
            <div style={person.theme}>
              <h1>{person.name}'s Todos</h1>
              <img
                className="avatar"
                src="https://i.imgur.com/7vQD0fPs.jpg"
                alt="Gregorio Y. Zara"
              />
            </div>
          );
        }

Rendering Techniques
  Rendering a list of elements in JSX
    Example: (rendering a list of animals from an array)
      function App() {
        const animals = ["Lion", "Cow", "Snake", "Lizard"];
        // the commented code works identically
        // const animalsList = animals.map((animal) => <li key={animal}>{animal}</li>)

        return (
          <div>
            <h1>Animals: </h1>
            <ul>
              {animals.map((animal) => {
                return <li key={animal}>{animal}</li>;
              })}
              // {animalsList}
            </ul>
          </div>
        );
      }

  Rendering a list of components in JSX 
    props - props are arugments passed into components
      <List animalList={animals} />
        This is an example of calling a component with props. In this case, 
        props.animalList would be called to retrieve the data that is 
        stored in the animals variable within the scope of the component 
        definition.

    Example: (would be useful in a case where many different lists of 
    animals are needed)
      function ListItem(props) {
        return <li>{props.animal}</li>
      }

      function List(props) {
        return (
          <ul>
            {props.animals.map((animal) => {
              return <ListItem key={animal} animal={animal} />;
            })}
          </ul>
        );
      }

      function App() {
        const animals = ["Lion", "Cow", "Snake", "Lizard"];

        return (
          <div>
            <h1>Animals: </h1>
            <List animals={animals} />
          </div>
        );
      }
    
  Conditionally Rendering UI
    Using ternary operator - return bool ? true_code : false_code;
      Example altering code above:
        return (
          <ul>
            {props.animals.map((animal) => {
              return animal.startsWith("L") ? <li key={animal}>{animal}</li> : null;
            })}
          </ul>
        );
      
    Using && operator - return bool && true_code;
      Will only return second operand if the first evaluates to true 

      Don't use directly use numbers on the left side of the && operator 
    
    Using if, if/else, or switch blocks 
      Example: 
        function List(props) {
          if (!props.animals) {
            return <div>Loading...</div>;
          }

          if (props.animals.length === 0) {
            return <div>There are no animals in the list!</div>;
          }

          return (
            <ul>
              {props.animals.map((animal) => {
                return <li key={animal}>{animal}</li>;
              })}
            </ul>
          );
        }

        function App() {
          const animals = [];

          return (
            <div>
              <h1>Animals: </h1>
              <List animals={animals} />
            </div>
          );
        }

      Same example with ternary operator:
        function List(props) {
          return (
            <>
              {!props.animals ? (
                <div>Loading...</div>
              ) : props.animals.length > 0 ? (
                <ul>
                  {props.animals.map((animal) => {
                    return <li key={animal}>{animal}</li>;
                  })}
                </ul>
              ) : (
                <div>There are no animals on the list!</div>
              )}
            </>
          );
        }
      
      Same example with && operator:
        function List(props) {
          return (
            <>
              {!props.animals && <div>Loading...</div>}
              {props.animals && props.animals.length > 0 && (
                <ul>
                  {props.animals.map((animal) => {
                    return <li key={animal}>{animal}</li>;
                  })}
                </ul>
              )}
              {props.animals && props.animals.length === 0 && <div>There are no animals in the list!</div>}
            </>
          );
        }

      Nested ternaries and && operators can be tough to look at

Keys - used for referencing elements
  Each element needs to have a unique identifier

  Using uuid package: 
    Example:
      // a list of todos, each todo object has a task and an id
      const todos = [
        { task: "mow the yard", id: uuid() },
        { task: "Work on Odin Projects", id: uuid() },
        { task: "feed the cat", id: uuid() },
      ];

      function TodoList() {
        return (
          <ul>
            {todos.map((todo) => (
              // here we are using the already generated id as the key.
              <li key={todo.id}>{todo.task}</li>
            ))}
          </ul>
        );
      }

  Using array index: 
    Only do this if the list will never change
      The index (key in this case) would change if elements are removed/ 
      inserted/moved, but keys need to be unique to the element they are 
      linked to in order to infer what was changed

    Example:
      const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

      function MonthList() {
        return (
          <ul>
            // here we are using the index as key
            {months.map((month, index) => (<li key={index}>{month}</li>))}
          </ul>
        );
      }

  JSX elements directly inside a map() call always need keys

  Keys can't be passed to short Fragment syntax (<>...</>)
    Can wrap everything in a div 
    
    Can also use a more explicit Fragment syntax
      <Fragment key={ele.id}> ... </Fragment>

      Fragments disappear from the DOM, so this will produce a flat list 
      of elements

      Example: 
        import { Fragment } from 'react';

        const listItems = people.map(person =>
          <Fragment key={person.id}>
            <h1>{person.name}</h1>
            <p>{person.bio}</p>
          </Fragment>
        );

  Components won’t receive key as a prop. Only used as a hint by React
    If your component needs an ID, you have to pass it as a separate prop: 
      <Profile key={id} userId={id} />

Props - used to pass data between components 
  Unidirectional data transfer from parent components to child components 
    Gives more explicit control over data, resulting in fewer errors 

  Component functions accept a single argument, a props object

  Props can be used to create very dynamic reusable components 
    Example:
      function Button(props) {
        const buttonStyle = {
          color: props.color,
          fontSize: props.fontSize + 'px'
        };

        return (
          <button style={buttonStyle}>{props.text}</button>
        );
      }

      export default function App() {
        return (
          <div>
            <Button text="Click Me!" color="blue" fontSize={12} />
            <Button text="Don't Click Me!" color="red" fontSize={12} />
            <Button text="Click Me!" color="blue" fontSize={20} />
          </div>
        );
      }

  Using destructuring and default variables
    You can also destructure your props to make the code more readable 
      Example: 
        function Button({ text, color, fontSize }) {
          const buttonStyle = {
            color: color,
            fontSize: fontSize + "px"
          };

          return <button style={buttonStyle}>{text}</button>;
        }

      It also lets you have easier access to the variables you're actually 
      using, since it's rare that you'll want to use the whole props object 

      Also lets you define default values at the same time 

    You can also set default props to reduce need for repetition
      Example: 
        function Button({ text, color, fontSize }) {
          const buttonStyle = {
            color: color,
            fontSize: fontSize + "px"
          };

          return <button style={buttonStyle}>{text}</button>;
        }

        Button.defaultProps = {
          text: "Click Me!",
          color: "blue",
          fontSize: 12
        };

        export default function App() {
          return (
            <div>
              <Button />
              <Button text="Don't Click Me!" color="red" />
              <Button fontSize={20} />
            </div>
          );
        }

      Default values for props are only used if a prop is missing or if it's 
      passed as {undefined}
        Note: {null} and {0} will not result in default values being used

    You can combine these default props and prop destructuring as well 
      Example: 
        function Button({ text = "Click Me!", color = "blue", fontSize = 12 }) {
          const buttonStyle = {
            color: color,
            fontSize: fontSize + "px"
          };

          return <button style={buttonStyle}>{text}</button>;
        }

  Passing functions as props
    Example: 
      function Button({ text = "Click Me!", color = "blue", fontSize = 12, handleClick }) {
        const buttonStyle = {
          color: color,
          fontSize: fontSize + "px"
        };

        return (
          <button onClick={handleClick} style={buttonStyle}>
            {text}
          </button>
        );
      }

      export default function App() {
        const handleButtonClick = () => {
          window.location.href = "http://www.google.com";
        };

        return (
          <div>
            <Button handleClick={handleButtonClick} />
          </div>
        );
      }

    Note in the above example that handleButtonClick is a variable storing 
    an anonymous function, not a function itself.
      It's important to pass through a reference to a function in props, 
      and not the actual function. If you had something like 
        handleClick = {handleButtonClick()}
      then the function would be called as the button renders, rather than 
      when it is clicked.

    You can also set the function to take an argument, but we need to 
    change how the function is called in that case 
      Example: 
        function Button({ text = "Click Me!", color = "blue", fontSize = 12, handleClick }) {
          const buttonStyle = {
            color: color,
            fontSize: fontSize + "px"
          };

          return (
            <button onClick={() => handleClick('https://www.theodinproject.com')} style={buttonStyle}>
              {text}
            </button>
          );
        }

        export default function App() {
          const handleButtonClick = (url) => {
            window.location.href = url;
          };

          return (
            <div>
              <Button handleClick={handleButtonClick} />
            </div>
          );
        }

      You can also do this using Curried functions 

  Forwarding props with JSX spread syntax 
    Example: 
      No spread syntax:
        function Profile({ person, size, isSepia, thickBorder }) {
          return (
            <div className="card">
              <Avatar
                person={person}
                size={size}
                isSepia={isSepia}
                thickBorder={thickBorder}
              />
            </div>
          );
        }

      Spread syntax: 
        function Profile(props) {
          return (
            <div className="card">
              <Avatar {...props} />
            </div>
          );
        }
    
    Use spread syntax with restraint
      If you’re using it in every other component, something is wrong
      
      Often, it indicates that you should split your components and pass 
      children as JSX

  Passing JSX as children 
    Nesting built-in browser tags is incredibly common, for instance a div 
    inside another div.

    You'll want to nest Components the same way

    Nested components are passed to parent components in a prop called 
    children
      Example: 
        App.js:
          import Avatar from './Avatar.js';

          function Card({ children }) {
            return (
              <div className="card">
                {children}
              </div>
            );
          }

          export default function Profile() {
            return (
              <Card>
                <Avatar
                  size={100}
                  person={{ 
                    name: 'Katsuko Saruhashi',
                    imageId: 'YfeOqp2'
                  }}
                />
              </Card>
            );
          }

        Avatar.js:
          import { getImageUrl } from './utils.js';

          export default function Avatar({ person, size }) {
            return (
              <img
                className="avatar"
                src={getImageUrl(person)}
                alt={person.name}
                width={size}
                height={size}
              />
            );
          }
    
State - Provides memory for components 
  Example: 
    https://codesandbox.io/p/devbox/unruffled-pasteur-6h36wf?embed=1&file=%2Fsrc%2FApp.jsx
    
    Whenever 
  
  useState hook
    import statement: 
      import { useState } from "react";

    Allows you to define state in a functional component 

    Takes an intial value as a parameter

    Returns an array with two elements, can be destructured to get:
      The current state value

      A function to update the state value 

    Example: 
      const [stateValue, setStateValue] = useState(initialValue);

      // from example above:
      const [backgroundColor, setBackgroundColor] = useState(initialColor);

  Rerendering - entire components are recreated from scratch, but now 
  returning the latest state value from useState 
    Rerendering is a key feature of React, it is what enables efficient 
    updates to the user interface in response to changes in the 
    underlying data.

  React reconciliation algorithm 
    Whenever rerendering occurs a new lightweight representation of the DOM 
    (Document Object Model) tree is created, this is called the virtual 
    DOM.

    The virtual DOM is used to track the current state of the UI 

    When a new virtual DOM is created, it is compared with the existing 
    virtual DOM and the minimal set of changes needed to update the actual 
    DOM is calculated. This process aims to optimize performance by only 
    applying necessary updates to the DOM, reducing unnecessary re-renders 
    and improving efficiency.

  How to define a state change function
    explain the stuff about the outer and inner arrow functions, and how 
    the state change function actually needs to return another function 
    that can be called later on when necessary (like when a button is 
    pressed)

  Hooks - Functions that use React features
    All hooks have the 'use' prefix (seen in useState)

    Hooks can only be called from the top level of a functional component 
      only available while React is rendering

    Hooks can't be called from inside loops or conditions 

    Naming convention
      const [something, setSomething] = useState(initialValue)

  State is isolated and private 
    State is local to the component instance on the screen 

    if you render a component twice, each will have its own isolated state

    If you want components to share state, the best way is to remove state 
    from the individual components and add it to their closest shared 
    parent

  State shouldn't be mutated (directly modified or changed in place).
    Example: 
      function Person() {
        const [person, setPerson] = useState({ name: "John", age: 100 });

        // BAD - Don't do this!
        const handleIncreaseAge = () => {
          // mutating the current state object
          person.age = person.age + 1;
          setPerson(person);
        };

        // GOOD - Do this!
        const handleIncreaseAge = () => {
          // copy the existing person object into a new object
          // while updating the age property
          const newPerson = { ...person, age: person.age + 1 };
          setPerson(newPerson);
        };

        return (
          <>
            <h1>{person.name}</h1>
            <h2>{person.age}</h2>
            <button onClick={handleIncreaseAge}>Increase age</button>
          </>
        );
      }

    Always use the setState functions provided by React for 
    updating state. While these functions facilitate state updates, they 
    don't guarantee immutable updates on their own. To ensure 
    immutability, it's essential to use spread syntax (...) with objects 
    to create a shallow copy of the state object. This shallow copy 
    duplicates the top-level structure of the object and contains 
    references to nested objects. By modifying this copy instead of the 
    original state, you ensure that changes are isolated and do not 
    affect the original data in memory."

  How state updates 
    State updates are asynchronous - so when setState functions are called,
    React will apply the update in the next component render.

    In React the state variables are not reactive, the components are.
      The current state value will stay the same until the component has 
      re-rendered completely.

    Be sure not to create infinite loops 
      Example: 
        function Component() {
          const [count, setCount] = useState(0);

          setCount(count + 1);

          return <h1>{count}</h1>;
        }

      This function will loop infinitely because the code inside the 
      Component definition will be executed each time the component renders
        This leads to the count increasing each time the count is 
        increased, which is an infinite loop

    State updater functions - functions that receive the previous state as
    an argument
      They ensure that you're working with the latest state when updating 
      it, which is crucial for multiple state updates that depend on the 
      previous state.

      Best practice: State updater functions should make all changes to the
      relevant state value in one go, ensuring that all updates are applied
      in one setState call.

      React's state update batching: React will combine multiple state 
      updates made within the same synchronous execution context (such as 
      within the same event handler) into one state update, optimizing 
      performance. If conflicting updates are made, React executes the code
      from the later call.

  Controlled Components - React components where you control the value of
  an HTML element using React state
    Useful for managing user input and ensuring synchronization between 
    the component's state and the HTML element's value 

    Use a controlled component whenever you need to capture user input 
    that can or will cause changes in the component or any other related 
    components

    Input elements are the easiest example to imagine. If the user input 
    affects other parts of the component, it would be a problem if you 
    had a native html input element whose value updates live with user 
    inputs without updating the state of the component.

    Example of a custom Input element: 
      function CustomInput() {
        const [value, setValue] = useState("");

        return (
          <input
            type="text"
            value={value}
            onChange={(event) => setValue(event.target.value)}
          />
        );
      }
    
    Other HTML elements/Use cases for controlled components:
      Checkboxes, select dropdowns, text areas

  State Structure - very important to setting yourself up for future 
  success with modifying state and debugging
    Guiding Principles:
      1. Group related state
        If variables are frequently updated at the same time, consider 
        merging them into a single object

        Keep in mind that if a state variable is an object, you can't 
        update only one field without explicity copying the other fields.
          setPosition({ x: 100 }) wouldn't work, need to use 
          setPosition({ ...position, x: 100 }) or define x and y as 
          separate state variables and use setX(100)

      2. Avoid contradictions 
        Don't structure state in a way where different pieces can 
        "disagree" with each other 

        Example: sometimes multiple boolean variables can be combined into 
        one status variable, especially if none of the booleans are 
        intended to be true or false at the same time.
          For example, instead of isLoading, isError, and isSuccess, you 
          could have a status variable with values like "loading", "error",
          or "success"
          
          if booleans are necessary, you can use the status variable to 
          define them without having them in state and worrying about them 
          falling out of sync with each other.

      3. Avoid redundancy 
        If information can be calculated with a component's props or 
        existing state, do that instead of adding it to that component's 
        state

        *Don't Mirror props in state
          Example: 
            Bad:
              function Message({ messageColor }) {
                const [color, setColor] = useState(messageColor);}
            Good:
              function Message({ messageColor }) {
                const color = messageColor;}
          
          State is only initialized during the first render, so changes in 
          the prop from the parent component will not trigger a state 
          update in the child.

          Mirroring should only be done when you WANT to ignore any updates
          from the parent component. In this case you should name the prop 
          with an 'initial' or 'default' prefix so this is clear.

      4. Avoid duplication 
        It's difficult to keep duplicated data in sync when updates are 
        being made, better to structure in a way that removes any duplicate
        data 

        Example: Suppose you have a list of items stored in one state 
        variable and a separate state variable to hold the value of the 
        selected item from that list. This setup creates duplication 
        because the selected item data is already present in the list 
        itself.
          A better approach is to structure your state in a way that 
          removes any duplicate data. In the example provided, storing the 
          selected item's ID in a separate state variable ensures that only
          essential information (the ID) is stored independently, while the
          actual item data remains within the items list. This approach 
          avoids redundancy, improves data coherence, and simplifies state 
          management.

          This especially applies if you're going to make live updates to 
          the items, so that the selected item will be triggered to update 
          wherever it's being used/displayed

      5. Avoid deep nesting 
        Deeply hierarchical state is not convenient to update, try to make 
        state flat when possible

        Two methods to make hierarchical state flat:
          1. Flatten your state variable into a single-layer object. 
          Instead of nesting children within their parent's object, each 
          item should be an object within the root object. Each item should
          contain at least three properties: its value, an ID, and an array
          of its children's IDs. Ensure there's a root object at index 0, 
          which contains the IDs of the outermost objects in its childIds 
          array.

          2. If your state comprises a few entities with intertwined 
          relationships, consider structuring your state accordingly. Use 
          arrays for each entity, containing objects representing 
          individual items as well as their parents and/or children within 
          other entities.

  Sharing state between components 
    If you want the state of two components to always change together, you 
    should remove it from the individual components and add it to their 
    closest common parent, then pass it down to them with props.

    Controlled vs Uncontrolled components 
      A component is "uncontrolled" if it contains any local state.

      "Controlled" components receive important information through their 
      props rather than their own local state. Their behavior is fully 
      specified by their parents.

      uncontrolled - easier to use within parents because less 
      confirguration is required, but less flexible when multiple need to 
      be coordinated together.

      controlled - maximum flexibility for coordination, but require parent
      components to fully configure them using props.
    
    Single source of truth 
      For each piece of state, there is a specific component that holds 
      that piece of information

      State will commonly have to be moved up and down depending on where 
      it is being used. You can imagine your component structure as a big 
      tree of parents and children. In the ideal structure, each piece of 
      state would be stored at the point on the tree where everywhere it's 
      used is extends from that component. 

      Deciding where state should live:
        Often, you can put the state directly into their common parent.
        
        You can also put the state into some component above their common 
        parent.
        
        If you can’t find a component where it makes sense to own the 
        state, create a new component solely for holding the state and 
        add it somewhere in the hierarchy above the common parent component

        Ask these questions for each piece of state:
          1. Which components use it?
          2. What is their common parent?
          3. Does it make sense for the state to live there, or should it 
          be contained higher in the component tree?

Rendering steps
  Any screen update in a React app happens in three steps:
    Trigger
      Only two things will trigger a render:
        1. Initial render 
        2. The component's, or one of its ancestors', state has been 
        updated
    Render
      Initial render - call root component 

      Re-renders - call the function component whose state update 
      triggered the render. This process is recursive and will continue 
      rendering any nested components next (components returned by the 
      originally updated component)
        This can be disabled if unnecessarily rendering nested components 
        causes performance issues
    Commit
      Initial render - uses appendChild() to add all DOM nodes

      Re-renders - Applies the minimal necessary operations to make the DOM
      match the latest rendering output. These steps are calculated by 
      React during rendering.

      Browser paint - After everything is rendered and the DOM is updated, 
      the browser will render the screen (called 'painting' to prevent 
      confusion between rendering terms)

  You can use Strict Mode to find mistakes in your components
    Strict mode will result in React calling each component's function 
    twice, which helps to identify mistakes if the output is not the same 

    Components should always return the same outputs given the same inputs 

  React does not touch the DOM if the rendering result is the same as last 
  time

  Rendering key words:
    Mounting - component is first rendered and inserted into the DOM 

    Re-rendering - occurs when a components state or props change, no 
    mounting or unmounting action occurs, the rendered output is just 
    updated

    Unmounting - occurs when the component is removed from the DOM

Side Effects - operations that affect something outside the scope of the 
function being executed
  Examples:
    Fetching data from an API 

    Directly manipulating DOM 
    
    Subscribing or unsubscribing to events

    Setting up timers 

  useEffect Hook - used to perform side effects in function components 
    Takes 2 arguments:
      1. a function containing the side effect logic 
      2. optional array of dependencies

    Syntax example: 
      without cleanup function:
        useEffect(() => {
          // side-effect logic
        }, [dependencies]);

      with cleanup function: 
        useEffect(
          () => {
            // execute side effect
            return () => {
              // cleanup function on unmounting or re-running effect
            }
          },
          // optional dependency array
          [/* 0 or more entries */]
        )

  How it works:
    1. Initial Render - the function passed to useEffect is executed after 
    the component renders 
    2. Dependency Array - if a dependency array is provider, the effect 
    will only run if one of the dependencies has changed since the last 
    render.
      If an empty array is provided, the effect only runs once (after the 
      initial render)
        Use cases: 
          Initial data fetch: when you need to load data from an API on 
          the initial render 

          Setting up event subscriptions

          Initializing libraries

      If no array is provided, the effect runs after every render 

    3. Cleanup function - if the effect returns a function, React will run 
    it before the component unmounts or before running the effect again 
    on subsequent renders.
      Useful for cleanup operations like unsubscribing from events

      You will typically want to define a cleanup function 
        If no cleanup function is returned, React will behave as if an 
        empty function was returned. 

    Effects are executed in the order they're declared

    Be cautious not to create infinite loops with dependencies 

    Component Lifecycle:
      1. Mount - when added to the screen
      2. Update (re-render) - when receiving new props or state
      3. Unmount - when removed from the screen

      Effects don't really fit into this lifecycle. 
        They can start and stop synchronizing multiple times while the 
        component is mounted
    
    Effect Lifecycle: 
      1. start synchronizing something - defined in Effect body
      2. stop synchronizing it - defined in cleanup function

      An effect describes how to synchronize an external system to the 
      current props and state

    Practical effect example: (chat room component)
      const serverUrl = 'https://localhost:1234';

      function ChatRoom({ roomId }) {
        useEffect(() => {
          const connection = createConnection(serverUrl, roomId);
          connection.connect();
          return () => {
            connection.disconnect();
          };
        }, [roomId]);
        // ...
      }

  Key Points:
    How to think of effects
      Instead of trying to think of effects as correlating with component 
      events ('after a render', 'before unmount'), always focus on a single 
      start/stop cycle at a time. It shouldn’t matter whether a component is 
      mounting, updating, or unmounting. All you need to do is to describe 
      how to start synchronization and how to stop it. 
      
      If you do it well, your Effect will be resilient to being started and 
      stopped as many times as it’s needed.

      This might remind you how you don’t think whether a component is 
      mounting or updating when you write the rendering logic that creates 
      JSX. You describe what should be on the screen, and React figures out 
      the rest.

      The exception would be if you provide an empty dependency array. In 
      this case the does not rely on any Reactive values within the 
      component, so no re-renders will trigger it to run until the 
      component unmounts, and the cleanup function is returned

    Each effect should represent a separate synchronization process 
      If you create an effect to synchronize something, then later on 
      realize a separate synchronization is required that has the same 
      dependencies, it can be temping to add the separate synchronization 
      logic into the same effect. 

      This is a bad practice because if you need to add another dependency 
      for the first synchronization and not the second, you will need to 
      create separate effects anyway. The causes here can be even more 
      subtle too - dependencies are reactive values, so issues may occur if
      you change how the state/props used in your effect are updated in a 
      way that shouldn't affect one of the synchronization processes.
      
      And worse yet, if you don't realize that you're unintentionally 
      changing the dependencies of the second synchronization, you may 
      produce a bug that's difficult to catch.

    Reactive values must be included in dependencies (state, props, and any
     component variables that are calculated from them)
      If the value is constant, meaning it will never change during a 
      re-render, then it doesn't need to be defined as a dependency.

      Anything else is a reactive value, and the effect needs to run again 
      if it's variables change so that it can make sure it is synchronized 
      with the current UI. Therefore all reactive values must be included 
      in dependencies.

      Keep in mind that component variables calculated from state are also 
      reactive values. To be safe, ANY variables used in the effect that 
      are not defined as constant within the component should be listed as 
      a dependency. (React linters will check for this)

    Effect Events - Used if you want to read the latest value of props 
    without "reacting" to it and re-synchronizing the Effect

    Avoid using objects and functions as dependencies 
      If you created objects and functions during rendering and then use 
      them in an Effect, they will always be 'different' on every render. 
      
      I'd imagine this isn't always an issue. But you can see how it would 
      become a huge issue if done unintentionally, potentially causing an 
      effect to synchronize way more often than intended.
        Which can be really bad if it's a large data fetch or interacting 
        with a rate limited server

  Best Practices:
    Avoid Side Effects in Rendering:
      Side effects should be placed inside useEffect rather than directly 
      in the rendering logic.

    Minimize Dependencies:
      Keep the dependency array as small as possible to prevent unnecessary
      re-renders.

    Asynchronous Operations:
      Handle asynchronous operations correctly by using async/await inside 
      the useEffect function or within an inner function.

      It is very important to consider how long the effect will take to 
      run. If the effect involves long-running operations (e.g., API 
      calls), you should define asynchronous functions within useEffect to 
      handle these operations. This ensures the UI remains responsive and 
      reactive.

  You might not need an effect 
    Effects let you "step outside" of React and synchronize with an 
    external system (ex: non-React widget, network, browser DOM)

    If there's no external system involved then you shouldn't need an 
    effect. 
      *unless you're using an effect with no dependency array as a 
      one-time initialization on mount*
        use cases: 
          Initializing a third party library 

          Initializing an internal (setting up a timer)

          Animations

    Cases where an effect is not needed 
      Transforming data for rendering 
        Rendering completes before an effect runs, then the component 
        rerenders if necessary, so to avoid unecessary renders just 
        do all data transformations at the top level of the component.
          Note: if you're tempted to put a data transformation into an 
          effect because of how long it takes, you should really be using 
          useMemo. Using memoization the code block will run during the 
          render instead of after, but it will store the initial result 
          and only run if one of it's dependencies changes.

      User events 
        These should be handled by event handler functions. If you try to 
        handle events with effects, you won't know what the user actually 
        did (what button they hit, what input they changed, etc.)

      

      







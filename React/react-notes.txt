Library vs Framework
  Inversion of control
    Library - you are in charge of the flow of the application, you choose 
    when and where to call the library.

    Framework - framework is in charge of the flow. It tells you where you 
    can plug in your own code, but it decides when to call this code.

  Opinionated
    The degree of freedom a library or framework gives the developer 
    dictates how "opinionated" it is. 

    More freedom = less opinionated

Vite 
  Used to quick start React projects
  
  Minimum steps required to configure your own project and development 
  environment:
    - Package Management (NPM, Yarn)
    - Module Bundling (Webpack, Parcel)
    - Compilation (Babel)
    - React itself 

    Vite can do most of this with a single terminal command
      npm create vite@latest my-first-react-app -- --template react

Default React Project Directory
  /public - static assests, i.e. images, icons, information files 

  /src - code that runs the app
    main.jsx - entry point of the application 
  
Components - break UI down into independent reusable chunks
  Components are javascript functions that return jsx (markup/js)

  Example: 
    function Greeting() {
      return <h1>&quot;Hello, World!&quot;</h1>;
    }

    export default Greeting;

  Components need to be exported (see example above)
    Make sure to capitalize!

  After being exported, Components can be imported to other React files
    Example from main.jsx:
      import Greeting from "./Greeting.jsx";

      ReactDOM.createRoot(document.getElementById("root")).render(
        <React.StrictMode>
          <Greeting />
        </React.StrictMode>,
      );
  
JSX - syntax extension that allows HTML-like markup inside a js file
  compiles down to plain javascript objects 

  JSX allows React to separate concerns by containing both rendering logic 
  and content in the same place (a component).

  There are other ways to write components but most devs prefer JSX for 
  it's conciseness. Most codebases use it 

  Rules of JSX:
    1. Return a single root element.
      You can return more than one element by wrapping them in a <div> or 
      by using a React fragment
        Example:
          return (
            <>
              HTML to return
            <>
          );
          // Could replace <></> with <div></div>

        *Note: Using a fragment will be invisible in the DOM, so the 
        elements within the fragment will be registered as their own 
        elements
          So this way the elements of the component are direct children of 
          the container.

          Using a div makes the div the direct child of the container, 
          while the individual elements are just children of the div

    2. Close all Tags.
      In HTML, many tags are self-closing and self-wrapping.
      
      In JSX however, we must explicitly close and wrap these tags.
        Examples:
          <input> would become <input />
          <li> would become <li></li>

    3. camelCase Most things.
      JSX turns to javascript, and attributes of elements become keys of 
      js objects

      For this reason, cannot use dashes or reserved words like 'class'
        Need to use className="class" instead
          Example:
            function App() {
              return (
              <div className="container">
                <svg>
                  <circle cx="25" cy="75" r="20" stroke="green" strokeWidth="2" />
                </svg>
              </div>
              );
            }
    
  Using Javascript within JSX
    Attributes can be passed as strings by enclosing in double or single 
    quotes

    Can also pass variables by enclosing in curly braces: {variableName}

    All javascript in JSX is contained within curly braces 
      You can also call functions
        Example: 
          const today = new Date();

          function formatDate(date) {
            return new Intl.DateTimeFormat(
              'en-US',
              { weekday: 'long' }
            ).format(date);
          }

          export default function TodoList() {
            return (
              <h1>To Do List for {formatDate(today)}</h1>
            );
          }
    
    Objects in JS are also denoted by enclosing in curly braces, so in JSX 
    you need to enclose in double curly braces if you want to define an 
    object 
      Really just an object inside JSX curlies
        Can also be written as so to make it easier to read:
          <ul style={
            {
              backgroundColor: 'black',
              color: 'pink'
            }
          }> 

      Example: 
        person={{ name: "Hedy Lamarr", inventions: 5 }};

      Actual Use Case: 
        export default function TodoList() {
          return (
            <ul style={{
              backgroundColor: 'black',
              color: 'pink'
            }}>
              <li>Improve the videophone</li>
              <li>Prepare aeronautics lectures</li>
              <li>Work on the alcohol-fuelled engine</li>
            </ul>
          );
        }

    You can create objects that contain not only content for your 
    components but the style as well
      Example: 
        const person = {
          name: 'Gregorio Y. Zara',
          theme: {
            backgroundColor: 'black',
            color: 'pink'
          }
        };

        export default function TodoList() {
          return (
            <div style={person.theme}>
              <h1>{person.name}'s Todos</h1>
              <img
                className="avatar"
                src="https://i.imgur.com/7vQD0fPs.jpg"
                alt="Gregorio Y. Zara"
              />
            </div>
          );
        }

Rendering Techniques
  Rendering a list of elements in JSX
    Example: (rendering a list of animals from an array)
      function App() {
        const animals = ["Lion", "Cow", "Snake", "Lizard"];
        // the commented code works identically
        // const animalsList = animals.map((animal) => <li key={animal}>{animal}</li>)

        return (
          <div>
            <h1>Animals: </h1>
            <ul>
              {animals.map((animal) => {
                return <li key={animal}>{animal}</li>;
              })}
              // {animalsList}
            </ul>
          </div>
        );
      }

  Rendering a list of components in JSX 
    props - props are arugments passed into components
      <List animalList={animals} />
        This is an example of calling a component with props. In this case, 
        props.animalList would be called to retrieve the data that is 
        stored in the animals variable within the scope of the component 
        definition.

    Example: (would be useful in a case where many different lists of 
    animals are needed)
      function ListItem(props) {
        return <li>{props.animal}</li>
      }

      function List(props) {
        return (
          <ul>
            {props.animals.map((animal) => {
              return <ListItem key={animal} animal={animal} />;
            })}
          </ul>
        );
      }

      function App() {
        const animals = ["Lion", "Cow", "Snake", "Lizard"];

        return (
          <div>
            <h1>Animals: </h1>
            <List animals={animals} />
          </div>
        );
      }
    
  Conditionally Rendering UI
    Using ternary operator - return bool ? true_code : false_code;
      Example altering code above:
        return (
          <ul>
            {props.animals.map((animal) => {
              return animal.startsWith("L") ? <li key={animal}>{animal}</li> : null;
            })}
          </ul>
        );
      
    Using && operator - return bool && true_code;
      Will only return second operand if the first evaluates to true 

      Don't use directly use numbers on the left side of the && operator 
    
    Using if, if/else, or switch blocks 
      Example: 
        function List(props) {
          if (!props.animals) {
            return <div>Loading...</div>;
          }

          if (props.animals.length === 0) {
            return <div>There are no animals in the list!</div>;
          }

          return (
            <ul>
              {props.animals.map((animal) => {
                return <li key={animal}>{animal}</li>;
              })}
            </ul>
          );
        }

        function App() {
          const animals = [];

          return (
            <div>
              <h1>Animals: </h1>
              <List animals={animals} />
            </div>
          );
        }

      Same example with ternary operator:
        function List(props) {
          return (
            <>
              {!props.animals ? (
                <div>Loading...</div>
              ) : props.animals.length > 0 ? (
                <ul>
                  {props.animals.map((animal) => {
                    return <li key={animal}>{animal}</li>;
                  })}
                </ul>
              ) : (
                <div>There are no animals on the list!</div>
              )}
            </>
          );
        }
      
      Same example with && operator:
        function List(props) {
          return (
            <>
              {!props.animals && <div>Loading...</div>}
              {props.animals && props.animals.length > 0 && (
                <ul>
                  {props.animals.map((animal) => {
                    return <li key={animal}>{animal}</li>;
                  })}
                </ul>
              )}
              {props.animals && props.animals.length === 0 && <div>There are no animals in the list!</div>}
            </>
          );
        }

      Nested ternaries and && operators can be tough to look at

Keys - used for referencing elements
  Each element needs to have a unique identifier

  Using uuid package: 
    Example:
      // a list of todos, each todo object has a task and an id
      const todos = [
        { task: "mow the yard", id: uuid() },
        { task: "Work on Odin Projects", id: uuid() },
        { task: "feed the cat", id: uuid() },
      ];

      function TodoList() {
        return (
          <ul>
            {todos.map((todo) => (
              // here we are using the already generated id as the key.
              <li key={todo.id}>{todo.task}</li>
            ))}
          </ul>
        );
      }

  Using array index: 
    Only do this if the list will never change
      The index (key in this case) would change if elements are removed/ 
      inserted/moved, but keys need to be unique to the element they are 
      linked to in order to infer what was changed

    Example:
      const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

      function MonthList() {
        return (
          <ul>
            // here we are using the index as key
            {months.map((month, index) => (<li key={index}>{month}</li>))}
          </ul>
        );
      }

  JSX elements directly inside a map() call always need keys

  Keys can't be passed to short Fragment syntax (<>...</>)
    Can wrap everything in a div 
    
    Can also use a more explicit Fragment syntax
      <Fragment key={ele.id}> ... </Fragment>

      Fragments disappear from the DOM, so this will produce a flat list 
      of elements

      Example: 
        import { Fragment } from 'react';

        const listItems = people.map(person =>
          <Fragment key={person.id}>
            <h1>{person.name}</h1>
            <p>{person.bio}</p>
          </Fragment>
        );

  Components won’t receive key as a prop. Only used as a hint by React
    If your component needs an ID, you have to pass it as a separate prop: 
      <Profile key={id} userId={id} />

Props - used to pass data between components 
  Unidirectional data transfer from parent components to child components 
    Gives more explicit control over data, resulting in fewer errors 

  Component functions accept a single argument, a props object

  Props can be used to create very dynamic reusable components 
    Example:
      function Button(props) {
        const buttonStyle = {
          color: props.color,
          fontSize: props.fontSize + 'px'
        };

        return (
          <button style={buttonStyle}>{props.text}</button>
        );
      }

      export default function App() {
        return (
          <div>
            <Button text="Click Me!" color="blue" fontSize={12} />
            <Button text="Don't Click Me!" color="red" fontSize={12} />
            <Button text="Click Me!" color="blue" fontSize={20} />
          </div>
        );
      }

  Using destructuring and default variables
    You can also destructure your props to make the code more readable 
      Example: 
        function Button({ text, color, fontSize }) {
          const buttonStyle = {
            color: color,
            fontSize: fontSize + "px"
          };

          return <button style={buttonStyle}>{text}</button>;
        }

      It also lets you have easier access to the variables you're actually 
      using, since it's rare that you'll want to use the whole props object 

      Also lets you define default values at the same time 

    You can also set default props to reduce need for repetition
      Example: 
        function Button({ text, color, fontSize }) {
          const buttonStyle = {
            color: color,
            fontSize: fontSize + "px"
          };

          return <button style={buttonStyle}>{text}</button>;
        }

        Button.defaultProps = {
          text: "Click Me!",
          color: "blue",
          fontSize: 12
        };

        export default function App() {
          return (
            <div>
              <Button />
              <Button text="Don't Click Me!" color="red" />
              <Button fontSize={20} />
            </div>
          );
        }

      Default values for props are only used if a prop is missing or if it's 
      passed as {undefined}
        Note: {null} and {0} will not result in default values being used

    You can combine these default props and prop destructuring as well 
      Example: 
        function Button({ text = "Click Me!", color = "blue", fontSize = 12 }) {
          const buttonStyle = {
            color: color,
            fontSize: fontSize + "px"
          };

          return <button style={buttonStyle}>{text}</button>;
        }

  Passing functions as props
    Example: 
      function Button({ text = "Click Me!", color = "blue", fontSize = 12, handleClick }) {
        const buttonStyle = {
          color: color,
          fontSize: fontSize + "px"
        };

        return (
          <button onClick={handleClick} style={buttonStyle}>
            {text}
          </button>
        );
      }

      export default function App() {
        const handleButtonClick = () => {
          window.location.href = "http://www.google.com";
        };

        return (
          <div>
            <Button handleClick={handleButtonClick} />
          </div>
        );
      }

    Note in the above example that handleButtonClick is a variable storing 
    an anonymous function, not a function itself.
      It's important to pass through a reference to a function in props, 
      and not the actual function. If you had something like 
        handleClick = {handleButtonClick()}
      then the function would be called as the button renders, rather than 
      when it is clicked.

    You can also set the function to take an argument, but we need to 
    change how the function is called in that case 
      Example: 
        function Button({ text = "Click Me!", color = "blue", fontSize = 12, handleClick }) {
          const buttonStyle = {
            color: color,
            fontSize: fontSize + "px"
          };

          return (
            <button onClick={() => handleClick('https://www.theodinproject.com')} style={buttonStyle}>
              {text}
            </button>
          );
        }

        export default function App() {
          const handleButtonClick = (url) => {
            window.location.href = url;
          };

          return (
            <div>
              <Button handleClick={handleButtonClick} />
            </div>
          );
        }

      You can also do this using Curried functions 

  Forwarding props with JSX spread syntax 
    Example: 
      No spread syntax:
        function Profile({ person, size, isSepia, thickBorder }) {
          return (
            <div className="card">
              <Avatar
                person={person}
                size={size}
                isSepia={isSepia}
                thickBorder={thickBorder}
              />
            </div>
          );
        }

      Spread syntax: 
        function Profile(props) {
          return (
            <div className="card">
              <Avatar {...props} />
            </div>
          );
        }
    
    Use spread syntax with restraint
      If you’re using it in every other component, something is wrong
      
      Often, it indicates that you should split your components and pass 
      children as JSX

  Passing JSX as children 
    Nesting built-in browser tags is incredibly common, for instance a div 
    inside another div.

    You'll want to nest Components the same way

    Nested components are passed to parent components in a prop called 
    children
      Example: 
        App.js:
          import Avatar from './Avatar.js';

          function Card({ children }) {
            return (
              <div className="card">
                {children}
              </div>
            );
          }

          export default function Profile() {
            return (
              <Card>
                <Avatar
                  size={100}
                  person={{ 
                    name: 'Katsuko Saruhashi',
                    imageId: 'YfeOqp2'
                  }}
                />
              </Card>
            );
          }

        Avatar.js:
          import { getImageUrl } from './utils.js';

          export default function Avatar({ person, size }) {
            return (
              <img
                className="avatar"
                src={getImageUrl(person)}
                alt={person.name}
                width={size}
                height={size}
              />
            );
          }
    
State - Provides memory for components 
  Example: 
    https://codesandbox.io/p/devbox/unruffled-pasteur-6h36wf?embed=1&file=%2Fsrc%2FApp.jsx
    
    Whenever 
  
  useState hook
    import statement: 
      import { useState } from "react";

    Allows you to define state in a functional component 

    Takes an intial value as a parameter

    Returns an array with two elements, can be destructured to get:
      The current state value

      A function to update the state value 

    Example: 
      const [stateValue, setStateValue] = useState(initialValue);

      // from example above:
      const [backgroundColor, setBackgroundColor] = useState(initialColor);

  Rerendering - entire components are recreated from scratch, but now 
  returning the latest state value from useState 
    Rerendering is a key feature of React, it is what enables efficient 
    updates to the user interface in response to changes in the 
    underlying data.

  React reconciliation algorithm 
    Whenever rerendering occurs a new lightweight representation of the DOM 
    (Document Object Model) tree is created, this is called the virtual 
    DOM.

    The virtual DOM is used to track the current state of the UI 

    When a new virtual DOM is created, it is compared with the existing 
    virtual DOM and the minimal set of changes needed to update the actual 
    DOM is calculated. This process aims to optimize performance by only 
    applying necessary updates to the DOM, reducing unnecessary re-renders 
    and improving efficiency.

  How to define a state change function
    explain the stuff about the outer and inner arrow functions, and how 
    the state change function actually needs to return another function 
    that can be called later on when necessary (like when a button is 
    pressed)

  Hooks - Functions that use React features
    All hooks have the 'use' prefix (seen in useState)

    Hooks can only be called from the top level of a functional component 
      only available while React is rendering

    Hooks can't be called from inside loops or conditions 

    Naming convention
      const [something, setSomething] = useState(initialValue)

  State is isolated and private 
    State is local to the component instance on the screen 

    if you render a component twice, each will have its own isolated state

    If you want components to share state, the best way is to remove state 
    from the individual components and add it to their closest shared 
    parent

  How to structure state 
    Don’t put values in state that can be calculated using existing values,
    state, and/or props.

    State shouldn't be mutated (directly modified or changed in place).
      Example: 
        function Person() {
          const [person, setPerson] = useState({ name: "John", age: 100 });

          // BAD - Don't do this!
          const handleIncreaseAge = () => {
            // mutating the current state object
            person.age = person.age + 1;
            setPerson(person);
          };

          // GOOD - Do this!
          const handleIncreaseAge = () => {
            // copy the existing person object into a new object
            // while updating the age property
            const newPerson = { ...person, age: person.age + 1 };
            setPerson(newPerson);
          };

          return (
            <>
              <h1>{person.name}</h1>
              <h2>{person.age}</h2>
              <button onClick={handleIncreaseAge}>Increase age</button>
            </>
          );
        }

      Always use the setState functions provided by React for 
      updating state. While these functions facilitate state updates, they 
      don't guarantee immutable updates on their own. To ensure 
      immutability, it's essential to use spread syntax (...) with objects 
      to create a shallow copy of the state object. This shallow copy 
      duplicates the top-level structure of the object and contains 
      references to nested objects. By modifying this copy instead of the 
      original state, you ensure that changes are isolated and do not 
      affect the original data in memory."

  How state updates 
    State updates are asynchronous - so when setState functions are called,
    React will apply the update in the next component render.

    In React the state variables are not reactive, the components are.
      The current state value will stay the same until the component has 
      re-rendered completely.

    Be sure not to create infinite loops 
      Example: 
        function Component() {
          const [count, setCount] = useState(0);

          setCount(count + 1);

          return <h1>{count}</h1>;
        }

      This function will loop infinitely because the code inside the 
      Component definition will be executed each time the component renders
        This leads to the count increasing each time the count is 
        increased, which is an infinite loop

    State updater functions - functions that receive the previous state as
    an argument
      They ensure that you're working with the latest state when updating 
      it, which is crucial for multiple state updates that depend on the 
      previous state.

      Best practice: State updater functions should make all changes to the
      relevant state value in one go, ensuring that all updates are applied
      in one setState call.

      React's state update batching: React will combine multiple state 
      updates made within the same synchronous execution context (such as 
      within the same event handler) into one state update, optimizing 
      performance. If conflicting updates are made, React executes the code
      from the later call.

  Controlled Components - React components where you control the value of
  an HTML element using React state
    Useful for managing user input and ensuring synchronization between 
    the component's state and the HTML element's value 

    Use a controlled component whenever you need to capture user input 
    that can or will cause changes in the component or any other related 
    components

    Input elements are the easiest example to imagine. If the user input 
    affects other parts of the component, it would be a problem if you 
    had a native html input element whose value updates live with user 
    inputs without updating the state of the component.

    Example of a custom Input element: 
      function CustomInput() {
        const [value, setValue] = useState("");

        return (
          <input
            type="text"
            value={value}
            onChange={(event) => setValue(event.target.value)}
          />
        );
      }
    
    Other HTML elements/Use cases for controlled components:
      Checkboxes, select dropdowns, text areas

  State Structure - very important to setting yourself up for future 
  success with modifying state and debugging
    Guiding Principles:
      1. Group related state
        If variables are frequently updated at the same time, consider 
        merging them into a single object

        Keep in mind that if a state variable is an object, you can't 
        update only one field without explicity copying the other fields.
          setPosition({ x: 100 }) wouldn't work, need to use 
          setPosition({ ...position, x: 100 }) or define x and y as 
          separate state variables and use setX(100)

      2. Avoid contradictions 
        Don't structure state in a way where different pieces can 
        "disagree" with each other 

        Example: sometimes multiple boolean variables can be combined into 
        one status variable, especially if none of the booleans are 
        intended to be true or false at the same time.
          For example, instead of isLoading, isError, and isSuccess, you 
          could have a status variable with values like "loading", "error",
          or "success"
          
          if booleans are necessary, you can use the status variable to 
          define them without having them in state and worrying about them 
          falling out of sync with each other.

      3. Avoid redundancy 
        If information can be calculated with a component's props or 
        existing state, do that instead of adding it to that component's 
        state

        *Don't Mirror props in state
          Example: 
            Bad:
              function Message({ messageColor }) {
                const [color, setColor] = useState(messageColor);}
            Good:
              function Message({ messageColor }) {
                const color = messageColor;}
          
          State is only initialized during the first render, so changes in 
          the prop from the parent component will not trigger a state 
          update in the child.

          Mirroring should only be done when you WANT to ignore any updates
          from the parent component. In this case you should name the prop 
          with an 'initial' or 'default' prefix so this is clear.

      4. Avoid duplication 
        It's difficult to keep duplicated data in sync when updates are 
        being made, better to structure in a way that removes any duplicate
        data 

        Example: Suppose you have a list of items stored in one state 
        variable and a separate state variable to hold the value of the 
        selected item from that list. This setup creates duplication 
        because the selected item data is already present in the list 
        itself.
          A better approach is to structure your state in a way that 
          removes any duplicate data. In the example provided, storing the 
          selected item's ID in a separate state variable ensures that only
          essential information (the ID) is stored independently, while the
          actual item data remains within the items list. This approach 
          avoids redundancy, improves data coherence, and simplifies state 
          management.

          This especially applies if you're going to make live updates to 
          the items, so that the selected item will be triggered to update 
          wherever it's being used/displayed

      5. Avoid deep nesting 
        Deeply hierarchical state is not convenient to update, try to make 
        state flat when possible

        
Rendering steps
  Any screen update in a React app happens in three steps:
    Trigger
      Only two things will trigger a render:
        1. Initial render 
        2. The component's, or one of its ancestors', state has been 
        updated
    Render
      Initial render - call root component 

      Re-renders - call the function component whose state update 
      triggered the render. This process is recursive and will continue 
      rendering any nested components next (components returned by the 
      originally updated component)
        This can be disabled if unnecessarily rendering nested components 
        causes performance issues
    Commit
      Initial render - uses appendChild() to add all DOM nodes

      Re-renders - Applies the minimal necessary operations to make the DOM
      match the latest rendering output. These steps are calculated by 
      React during rendering.

      Browser paint - After everything is rendered and the DOM is updated, 
      the browser will render the screen (called 'painting' to prevent 
      confusion between rendering terms)

  You can use Strict Mode to find mistakes in your components
    Strict mode will result in React calling each component's function 
    twice, which helps to identify mistakes if the output is not the same 

    Components should always return the same outputs given the same inputs 

  React does not touch the DOM if the rendering result is the same as last 
  time
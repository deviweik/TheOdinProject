irb - type irb in console to open Interactive Ruby, lets you interactively
execute Ruby code and see the results immediately. 'Exit' to exit

Syntax
  tab - 2 spaces

  comments - `# this is a comment`

  always use snake_case for variables, methods, and files

  Use PascalCase (camelCase with first word capitalized as well) for 
  declaring class names

  semicolons are never required in Ruby, but they allow you to write 
  multiple lines of code on one line.

  Constant variables - all caps 
    FOUR = 'four'
    FIVE = 5

  puts vs return
    Every expression (pretty much anything written in Ruby) will return 
    something. It may return an error or nil, but it will return something.

    puts - telling Ruby to print something to the screen, but puts will not 
    return that value. It returns nil instead
      ex:
        > a = puts "stuff"
        "stuff"
        => nil
        > puts a 
        # blank space here from printing `nil`
        => nil

  Tips on reading documentation pages:
    https://launchschool.com/books/ruby/read/preparations#usingacodeeditor
  
Data Types
  Numbers, Strings, Symbols, Booleans, Literals, Basic Data Structures (
  arrays, hashes)

  Numbers 
    Operators
      +, -, *, /, modulus: %, exponent: **

      Equality - Ruby uses `==` for equality comparisions, returns T/F
        Like === in JS, == in Ruby will return false if the operands' types
        are different, ex: '4' == 4 => false

    Number Types
      Integers: whole Numbers
        arithmetic with integers will always result in an integer
      Floats: decimals

      Converting Number Types
        # To convert an integer to a float:
        13.to_f   #=> 13.0

        # To convert a float to an integer:
        13.0.to_i #=> 13
        13.9.to_i #=> 13
        # As shown here, it will simply cut off the decimal, no rounding

        Some interesting details on string -> number conversions
          irb :001 > '4'.to_i
          => 4

          irb :002 > '4 hi there'.to_i
          => 4

          irb :003 > 'hi there 4'.to_i
          => 0

          irb :004 > '4'.to_f
          => 4.0

          irb :005 > '4 hi there'.to_f
          => 4.0

          irb :006 > 'hi there 4'.to_f
          => 0.0
      
    Number Methods 
      #even? and #odd?
        6.even? # => true
        6.odd? # => false

      Remainder Methods
        #remainder - computes and returns the remainder of an integer 
        division operation
          16.remainder(5) => 1
        
        #divmod - computes both the integer result and the modulo value
          16.divmod(5) => [3,1]

        Modulo vs remainder operations
          Modulo - returns a positive integer when the 2nd operand is 
          positive, and a negative integer when the 2nd operand is negative

          Remainder ops- return a + integer when the 1st operand is +, a 
          - integer when the 1st operand is negative.

          Only matters if you need to use negative integers with these 
          functions for some reason, so best practice is to try to only
          use positive integers if possible.
    
  Strings
    Syntax
      Like JS, can use single or double quotation marks
      Difference: string interpolation and escape characters will only work
      inside double quotation marks

    Concatenation
      # With the plus operator:
      "Welcome " + "to " + "Odin!"    #=> "Welcome to Odin!"

      # With the shovel operator:
      "Welcome " << "to " << "Odin!"  #=> "Welcome to Odin!"

      # With the concat method:
      "Welcome ".concat("to ").concat("Odin!")  #=> "Welcome to Odin!"

      Note: adding numbers as strings will result in string concatenation 
        '1' + '1' => '11'

      Unlike JS, you cannot add a number to a string or vice versa.
        'one' + 1 => error
        1 + 'one' => error
        1 + '1' => error
        1 + '1'.to_i => 2
        1.to_s + '1' => "11"

    Substrings
      "hello"[0]      #=> "h"

      "hello"[0..1]   #=> "he"

      "hello"[0, 4]   #=> "hell"

      "hello"[-1]     #=> "o"

    Escape Characters 
      \\  #=> Need a backslash in your string?
      \b  #=> Backspace
      \r  #=> Carriage return, for those of you that love typewriters
      \n  #=> Newline. You'll likely use this one the most.
      \s  #=> Space
      \t  #=> Tab
      \"  #=> Double quotation mark
      \'  #=> Single quotation mark

    Interpolation - evaluating strings with placeholder variables
      name = "Odin"

      puts "Hello, #{name}" #=> "Hello, Odin"
      puts 'Hello, #{name}' #=> "Hello, #{name}"

    String Methods
      #capitalize
        "hello".capitalize #=> "Hello"

      #include?
        "hello".include?("lo")  #=> true

        "hello".include?("z")   #=> false
      
      #upcase
        "hello".upcase  #=> "HELLO"

      #downcase
        "Hello".downcase  #=> "hello"

      #empty?
        "hello".empty?  #=> false

        "".empty?       #=> true

      #length
        "hello".length  #=> 5

      #reverse
        "hello".reverse  #=> "olleh"

      #split
        "hello world".split  #=> ["hello", "world"]

        "hello".split("")    #=> ["h", "e", "l", "l", "o"]

      #strip
        " hello, world   ".strip  #=> "hello, world"

      These are only a few examples, here are some more to show the 
      possibilities with ruby:
        "he77o".sub("7", "l")           #=> "hel7o"

        "he77o".gsub("7", "l")          #=> "hello"

        "hello".insert(-1, " dude")     #=> "hello dude"

        "hello world".delete("l")       #=> "heo word"

        "!".prepend("hello, ", "world") #=> "hello, world!"

    Converting other objects to strings
      5.to_s        #=> "5"

      nil.to_s      #=> ""

      :symbol.to_s  #=> "symbol"
  
  Symbols
    Basically, strings are data types that store a collection of characters 
    that can be changed. So every time a string is used, Ruby has to store
    it in memory, even if that same string has already been stored 
    somewhere else. Symbols differ from strings in that they are only 
    stored in memory once, which can greatly increase performance in some
    cases. 
    
    Here is some code displaying this difference:
      "string" == "string"  #=> true

      "string".object_id == "string".object_id  #=> false

      :symbol.object_id == :symbol.object_id    #=> true

    An example of where symbols are preferred is for keys in hashes.

    Symbols are created by putting a colon at the beginning of some text:
      `:my_symbol`

  Booleans
    True and False 
      these are true and false, very standard

    Nil 
      In Ruby, nil = nothing

      Everything in Ruby will have a return value, so when any code has
      nothing to return, it will return `nil`.

      You can check if something is a nil type using .nil?
        "Hello, World".nil? => false

      When used in an expression, nil will be treated as false
        Despite this, false == nil => false

  Literals - any notation that represents a fixed value in source code
    examples:
      'Hello, world!'          # string literal
      375                      # integer literal
      3.141528                 # float literal
      true                     # boolean literal
      { 'a' => 1, 'b' => 2 }   # hash literal
      [ 1, 2, 3 ]              # array literal
      :sym                     # symbol literal
      nil                      # nil literal

  Basic Data Structures (Array/Hashes introduction)
    Arrays
      Syntax - array literal denoted by square brackets `[]`, comma-separated

      Ruby indexes from 0: [1,2,3,4,5][0] => 1

    Hashes - a hash is a set of key-value pairs
      Syntax - hash literal denoted by curly braces `{}`

      irb :001 > {:dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
      => "meows"

Variables 
  variable names are always reusable
  age = 18 => 18
  age = 18 + 5 => 23
  age += 5 => 28 (can also use -=, *=, /=)
  
  Variable naming
    Ruby was created to read and write as naturally as possible, so var 
    names should describe what the variable represents as clearly as 
    possible.

    snake_case

  Variables are references to a location in your computers memory
    This can lead to some unexpected results
      ex:
        string_location = "here"
        copy_location = string_location
        string_location.upcase!

        string_location => "HERE"
        copy_location => "HERE"

        string_location = "moved over there"
        copy_location => "HERE" 
          # changing the first var to reference a new place in comp's 
          # memory will not change the reference stored in second var

        Be careful assigning variables to other variables
  
  Getting Data from a User 
    gets - "get string"

    irb(main):008:0> name = gets
    Devin
    => "Devin\n"    

    irb(main):009:0> name = gets.chomp
    Devin
    => "Devin"  #chomp method can remove the new line

  Variable Scope 
    Blocks - blocks are pieces of code that follow a method's invocation
      ex:
        total = 0
        [1, 2, 3].each { |number| total += number }
        puts total # 6
        # the block here is inside the curly braces {}
          common practice is to use {} for one liners, 
          do |var| ... end for more

        total = 0
        [1, 2, 3].each do |number|
          total += number
        end
        puts total # 6
        # the block here is: do |number| ... end

      Variables defined outside the block (total) can be used inside the
      block, but any variables defined inside the block (number) cannot be
      used outside of the block. 
        Overall: Inner scope can access vars from outer scope, but not 
        vice versa.

  Variable Types
    Constants - created by capitalizing every letter in the var name
      note: constants can be reassigned in Ruby, but it will throw a 
      warning to let you know there was a previous definition

    Global Variables - available throughout the whole app, overriding all
    scope boundaries
      Defined by adding a $ before the var name
        $var = "global var"

      Generally avoided because they can lead to unexpected complications

    Class Variables - accessible by instances of your class, as well as 
    the class itself.
      Used when you need to declare a var that is related to a class, but
      each instance of that class does not need its own value for the var

      declared with two @ symbols before the var name
        @@instances = 0

    Instance Variables - Available throughout the current instance of the
    parent class.
      Declared with one @ symbol before the var name
        @var = 'instance var'

    Local Variables - most common, obey all scope boundaries

Inputs and Outputs
  Outputs
    print vs puts
      both output to irb/ REPL environment or into the command line and 
      return nil

      The difference is that puts will append a new line (\n) to the end of
      the output, while print will not.

    puts
      puts will attempt to convert everything into a string 
      (by calling to_s).
        important because if you’re trying to puts an array with nil 
        values it will show some blanks lines
          Example:
            puts [1,nil,nil,2]
            1

            
            2
          
      puts has a shorthand `p`
        puts "Hello, World!" is basically the same as:
        p "Hello, World!"

        there are some differences though:
          irb(main):008:0> puts "Hello"
          Hello
          => nil                                                         
          irb(main):009:0> p "Hello"
          "Hello" 
          => "Hello"
            # p will also show things like escape characters that 
          would not otherwise be clearly visible (useful for debugging)
  
    putc - only prints one character (the first) but returns the whole
    string.

  Inputs
    gets - causes program execution to stop and wait for user input, 
    continues after the user presses enter

    Unlike print/puts, gets will return what it outputs instead of just 
    returning nil

    gets also appends a new line (\n) to the end of whatever you input. 
    (the value that gets returns also has the \n)

    Full example of getting an input:
      puts "Enter a value :"
      val = gets
      puts val

      This will produce the following result −
      Enter a value :
      This is entered value
      This is entered value

Conditionals in Ruby 
  false
    Ruby only reads `nil` and `false` as falsy values
      Unlike other languages, 0 or empty strings ("") won't read as false

  if statement
    Syntax:
      if statement_to_be_evaluated == true
        # do something here...
      elsif another_statement_to_be_evaluated == true
        # do something else here...
      else
        # do something else here..
      end
    
    If there's only one line in the block of code you can write it this
    way:
      puts "example" if 1 < 2

  Boolean Logic
    equals ( == )

    not equal ( != )

    greater than ( > ) or equal to ( >= )

    less than ( < ) or equal to ( <= )

    #eql? - checks value type and actual value
      5.eql?(5.0) => false  # 5 is integer, 5.0 is float
      5.eql?(5) => true

    #equal? - checks if values are the exact same object in memory
      This has some interesting complications:
        Integers
          Computers store integers in memory differently
            a = 5
            b = 5
            a.equal?(b) #=> true
      
      Example:
        a = "hello"
        b = "hello"
        a.equal?(b) #=> false

    Spaceship operator 
      This is a unique operator that doesn't return true/false, instead it
      returns three numberical values

      Example:
        5 <=> 10    #=> -1    (-1 when left is less than right)
        10 <=> 10   #=> 0     (0 when left is equal to the right)
        10 <=> 5    #=> 1     (1 when left is greater than right)

      Most commonly used in sorting functions

  Logical Operators
    and (&&), or (||), not (!)
      Short circuit evaluation
        && and || will not evaluate the second expression if the first does
        not meet their criteria.
          If the first expression in an && operator evaluates to false, it
          will not even check the second.

          If the first expression in an || operator evaluates to true, it 
          will not check the second expression.

  Case Statements (like switch)
    ex: 
      grade = 'F'

      did_i_pass = case grade #=> create a variable `did_i_pass` and assign
      the result of a call to case with the variable grade passed in
        when 'A' then "Hell yeah!"
        when 'D' then "Don't tell your mother."
        else "'YOU SHALL NOT PASS!' -Gandalf"
      end

    If you have more complex code, just remove the `then` and put the code
    on the next line.
      ex: 
        grade = 'F'

        case grade
        when 'A'
          puts "You're a genius"
          future_bank_account_balance = 5_000_000
        when 'D'
          puts "Better luck next time"
          can_i_retire_soon = false
        else
          puts "'YOU SHALL NOT PASS!' -Gandalf"
          fml = true
        end

  Unless Statement 
    Works in the opposite way as an if statement, only processes the code
    if the statement evaluates to false
    
    age = 19
    puts "Welcome to a life of debt." unless age < 18

    unless age < 18
      puts "Down with that sort of thing."
    else
      puts "Careful now!"
    end

  Ternary Operator 
    Syntax
      conditional statement ? <execute if true> : <execute if false>

Loops in Ruby
  `loop` - Ruby has a loop initiated with `loop` that will continue 
  looping until you specifically tell it to stop with `break`
    Example for syntax:
      i = 0
      loop do
        puts "i is #{i}"
        i += 1
        break if i == 10
      end

    In general, this loop is not really used, if you are using it, there's
    probably a better solution available.

  While loop
    Example for syntax:
      i = 0
      while i < 10 do
        puts "i is #{i}"
        i += 1
      end
    
    Like `loop` loop except more readable with the break condition 
    declared in the initializer

    One common use case is repeatedly prompting a question until an 
    acceptable answer is provided:
      while gets.chomp != "yes" do
        puts "Will you go to prom with me?"
      end
    
  Until Loop
    Example for syntax:
      i = 0
      until i >= 10 do
        puts "i is #{i}"
        i += 1
      end
    
    This is the opposite of a while loop, it will continue as long as the
    provided conditional statement evaluates to false

    This makes them relatively interchangable. Ultimately the better one
    to use is dictated by the break condition; if you find yourself using
    a while loop with a `!` to negate the condition, it makes more sense
    to just use an until loop.

  Ranges
    Ranges can be used like for loops in matlab(/python maybe?) where you 
    loop over an array, but it's honestly not very similar to that syntax/
    usage wise.

    You can make the ranges inclusive or exclusive:
      Inclusive: (1..5) #=> 1, 2, 3, 4, 5 
      Exclusive: (1...5) #=> 1, 2, 3, 4

      You have to use other looping methods to actually implement these in
      a looping application:
        ex 1 - for:
          for n in 1..5
            puts n
          end
        
        ex 2 - each:
          (1..5).each do |n|
            puts n
          end

        These will both output:
          1
          2
          3
          4
          5
        
    You can also make ranges with letters: ('a'..'z') => 'a', 'b', ... 'z'

  For Loop
    Example for syntax:
      for i in 0..5
        puts "#{i} zombies incoming!"
      end

  Times Loop  (`#times` loop)
    Example for syntax:
      5.times do
        puts "Hello, world!"
      end

    IMPORTANT: all loops will start counting from 0
    (also you can access the current iteration number like below)
      so this code:
        3.times do |n|
          puts n
        end
      
      would output:
        0
        1
        2

  Upto and Downto Loops
    #upto - iterate from start # up to another #
    #downto - iterate from start # down to another #

    Syntax examples:
      5.upto(10) {|num| print "#{num} " }     #=> 5 6 7 8 9 10

      10.downto(5) {|num| print "#{num} " }   #=> 10 9 8 7 6 5
  
  Keywords
    break - exits the loop whenever executed, usually blocked inside 
    conditional statement

    next - skips the rest of the current iteration and continues with the
    next.
      ex:
        (1..10).each do |n|
          next if n % 2 == 0
          puts n
        end
      
    redo - repeats current iteration from the beginning
      ex:
        i = 0
        while i < 5
          i += 1
          redo if i == 3
          puts i
        end

    retry - restarts the entire loop from the beginning
      ex: 
        i = 0
        while i < 5
          begin
            i += 1
            raise if i == 3
            puts i
          rescue
            retry
          end
        end

        This example also uses other keywords `raise` and `rescue`
        Raise raises an exception, which is caught by the rescue block, 
        which then calls retry to restart from the beginning

    Here's another example that shows how raise and rescue can be used:
      (thanks chatGPT)

      def divide(numerator, denominator)
        raise ZeroDivisionError, "Cannot divide by zero" if denominator == 0
        numerator / denominator
      rescue ZeroDivisionError => e
        puts "Error: #{e.message}"
      end

      puts divide(10, 0) # Outputs "Error: Cannot divide by zero"

Arrays
  Syntax
    num_array = [1, 2, 3, 4, 5]
    str_array = ["This", "is", "a", "small", "array"]

  Creating Arrays
    [] - creating an array this way is called an 'array literal'

    Array.new - method to create an array
      you can also include up to 2 optional arguments 
      (initial size and default value):
        Array.new               #=> []
        Array.new(3)            #=> [nil, nil, nil]
        Array.new(3, 7)         #=> [7, 7, 7]
        Array.new(3, true)      #=> [true, true, true]

    Arrays use 0-based indexing in Ruby

    Attempting to index an invalid position results in 'nil'

    Arrays can also take negative indices which start from the end of an 
    array, starting with [-1]

    #first and #last methods - returns a new array containing the first or
    last n elements of the array
      myArray.first(n) -> new array with first n elements of myArray

  Adding/Removing from Arrays
    #push - can take multiple inputs and returns a new array with those 
    inputs appended.

    << shovel operator - appends one element to the end of your array
      myArray = [1,2]
      myArray << 3 => [1, 2, 3]

      You can also add more than 1 element by using the splat operator (*)
      before the input array to split it into individual elements:
        num_array = [1, 2]
        num_array << *[3, 4, 5] => [1, 2, 3, 4, 5]

    #pop - removes the element at the end of the array and returns the 
    element that was removed:
      num_array.pop => 5
      num_array => [1, 2, 3, 4]

    #shift - remove from the beginning of an array
      num_array.shift => 1
      num_array => [2, 3, 4]
    
    #unshift - add to the beginning of an array
      num_array.unshift(1) => [1, 2, 3, 4]

    #pop and #shift can also take integer elements that will result in 
    that many elements being removed from the array

  Adding and Subtracting Arrays
    [1, 2, 3] + [3, 4, 5] => [1, 2, 3, 3, 4, 5]

    #concat works the same way:
      a = [1, 2, 3]
      b = [3, 4, 5]

      a + b         #=> [1, 2, 3, 3, 4, 5]
      a.concat(b)   #=> [1, 2, 3, 3, 4, 5]

    Subtracting arrays will remove any elements from the first array that 
    appear in the second:
      [1, 1, 1, 2, 2, 3, 4] - [1, 4]  #=> [2, 2, 3]

  Basic Array Methods
    num_array.methods => gives a very long list of available methods

    Method examples:
      [].empty?               #=> true
      [[]].empty?             #=> false
      [1, 2].empty?           #=> false

      [1, 2, 3, 4].first      #=> 1
      [1, 2, 3, 4].last       #=> 4

      a = [1, 2, [3, 4], [5, 6, 7]]
      a.last.delete(a.last.first) #=> 5
      a                       #=> [1, 2, [3, 4], [6, 7]]

      [1, 2, 3].length        #=> 3

      [1, 2, 3].reverse       #=> [3, 2, 1]

      [1, 2, 3].include?(3)   #=> true
      [1, 2, 3].include?("3") #=> false

      [1, 2, 3].join          #=> "123"
      [1, 2, 3].join("-")     #=> "1-2-3"

      #sort - sorts the array, not destructive (errors if comparing 
      differing data types like an array with a number)
      a = [5, 3, 8, 2, 4, 1]  #=> [5, 3, 8, 2, 4, 1]
      a.sort                  #=> [1, 2, 3, 4, 5, 8]

      #product - combine two arrays by returning an array that is a 
      combination of all elements from all arrays
      [1, 2, 3].product([4, 5]) 
      #=> [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]

      a = [1, 2, [3, 4, 5], [6, 7]]   #=> [1, 2, [3, 4, 5], [6, 7]]
      a.flatten                       #=> [1, 2, 3, 4, 5, 6, 7]
      #flatten is not destructive

      #delete_at() - permanently removes the array element at the index 
      that is inputted

      #delete - if you don't know the index of the value you want to 
      delete, you can use the delete method to remove any instances of the
      provided value from an array

      #uniq - iterates through an array and deletes any duplicate elements
        myArray = [1, 1, 2, 3, 4, 4]
        myArray.bang! => [1, 2, 3, 4]
        myArray => [1, 1, 2, 3, 4, 4]

        This is not a destructive method, but you can make it one by 
        adding a bang suffix (!) to the method:
          myArray = [1, 1, 2, 3, 4, 4]
          myArray.bang! => [1, 2, 3, 4]
          myArray => [1, 2, 3, 4]

      #select - iterate over an array and return a new array that only 
      contains elements that return true to the provided expression
        numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
          => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        numbers.select { |number| number > 4 }
          => [5, 6, 7, 8, 9, 10]
        numbers
          => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

      #to_s - returns a string representation of an array (not destructive)

      Methods that use blocks
        Blocks
          Can be passed using the 'do...end' syntax
            example using #each:
              array = [1, 2, 3, 4, 5]
              array.each do |element|
                puts "The element is #{element}"
              end
            
          Also passed using curly braces '{}'
            array.each_index { |i| puts "This is index #{i}" }
              |i| - this is the block parameter
              the next part is the block of code that gets executed for 
              each index

            Here's an example using #map:
              array = [1, 2, 3, 4, 5]
              doubled_array = array.map { |element| element * 2 }

              puts doubled_array => [2, 4, 6, 8, 10]

        #each_index - iterates through an array like #each but the 
        variable represents the index of the element as opposed to the 
        value. 

        #each_with_index - can use value and index as block parameters
          arr.each_with_index{|value, index| puts "#{value}, #{index}"}

        #map - invokes the given block once for each element in the 
        collection, creates and returns a new array containing the values 
        returned by the block

        #map vs #each
          #each example:
            a = [1, 2, 3]
            a.each { |e| puts e + 2 }
            3
            4
            5
            => [1, 2, 3]

          #map example:
          a = [1, 2, 3]
          a.map { |x| puts x**2 }
          1
          4
          9
          => [nil, nil, nil]
          
          puts will always return nil when the block is invoked, which 
          makes up the values in the newly created array.

        Overall Rule: use each for iteration and map for transformation.



  Comparing Arrays 
    == operator - compare arrays for equality

Hashes
  Similar to objects in JS

  Hashes are like arrays (collection of values) that are indexed by key 
  rather than index. The two main advantages of this are 1. being able to 
  select the value you want without figuring out the numerical index, and 
  2. values stored in hashes don't need to be stored in any particular 
  order.

  Hashes vs Arrays
    When deciding whether to use a hash or an array, ask yourself a few questions:
      Does this data need to be associated with a specific label? If yes, 
      use a hash. If the data doesn't have a natural label, then typically 
      an array will work fine.

      Does order matter? If yes, then use an array. As of Ruby 1.9, hashes
      also maintain order, but usually ordered items are stored in an 
      array.

      Do I need a "stack" or a "queue" structure? Arrays are good at 
      mimicking simple "first-in-first-out" queues, or "last-in-first-out" 
      stacks.

  Creating Hashes
    Hash literal - "{}" curly braces
      Ex: 
        my_hash = {
          "a random word" => "ahoy",
          "Dorothy's math test score" => 94,
          "an array" => [1, 2, 3],
          "an empty hash within a hash" => {}
        }

      key => value (=> is called a hash rocket)

    ::new method 
      my_hash = Hash.new
      my_hash               #=> {}

  Accessing Hash Values 
    Syntax is very similar to indexing arrays:
      shoes = {
        "summer" => "sandals",
        "winter" => "boots"
      }

      shoes["summer"]   #=> "sandals"

    Attempting to access a key that doesn't exist will return nil:
      shoes["hiking"]   #=> nil

      If you need to return an error when the key does not exist, you can
      use the fetch method:
        shoes.fetch("hiking")   #=> KeyError: key not found: "hiking"

        This method can also be given a default value to return instead of
        an error:
          shoes.fetch("hiking", "hiking boots") #=> "hiking boots"

  Adding and Changing Data
    Can add data the same as you would to an array:
      shoes["fall"] = "sneakers"

      Can also change the values of existing keys this way:

  Removing Data
    #delete - shoes.delete("fall")    #=> "sneakers"

  Methods
    Hashes and arrays both employ Ruby's Enumerable module, not sure what
    this means but it leads to them both responding to many of the same 
    methods

    Methods specific to hashes:
      #keys - returns array of the keys from a hash

      #values - returns array of the values from a hash

      #key? - allows you to check if a hash contains a specific key,
      returns a boolean

      #select - pass it a block and it will return any key-value pairs 
      that evalutate to true
        name_and_age = { "Bob" => 42, "Steve" => 31, "Joe" => 19}
        name_and_age.select { |k,v| k == "Bob" }  
        => {"Bob"=>42}
        name_and_age.select { |k,v| (k == "Bob") || (v == 19) }
        => {"Bob"=>42, "Joe"=>19}

      #fetch - defined above

      #to_a - returns a nested array version of your hash, not destructive
        name_and_age.to_a
        => [["Bob", 42], ["Steve", 31], ["Joe", 19]]
        name_and_age
        => {"Bob"=>42, "Steve"=>31, "Joe"=>19}


  Merging Two Hashes
    #merge - merges two hashes, any duplicate keys will take on the value
    of the hash getting merged in (hash2 in this case)
      hash1.merge(hash2)

  Symbols as Hash keys
    symbols are commonly used as hash keys due to simplified syntax when 
    defining hash literals:
      # 'Rocket' syntax
      american_cars = {
        :chevrolet => "Corvette",
        :ford => "Mustang",
        :dodge => "Ram"
      }
      # 'Symbols' syntax      *ONLY WORKS FOR SYMBOLS*
      japanese_cars = {
        honda: "Accord",
        toyota: "Corolla",
        nissan: "Altima"
      }
    
    When you use symbols as keys you also obviously have to use a symbol 
    to access it's value:
      american_cars[:ford]    #=> "Mustang"
      japanese_cars[:honda]   #=> "Accord"

  Iterating over Hashes 
    Ex:
      person = {name: 'bob', height: '6 ft', weight: '160 lbs', hair: 
      'brown'}

      person.each do |key, value|
        puts "Bob's #{key} is #{value}"
      end

      Output:
        Bob's name is bob
        Bob's height is 6 ft
        Bob's weight is 160 lbs
        Bob's hair is brown

Methods
  Allow you to name sections of your code that can be called in other 
  places in the program. DRY - Don't repeat yourself
    if you find yourself rewriting sections of code, define it as a 
    method instead and apply it that way.

  In Ruby, methods and functions are essentially interchangable because 
  ruby is purely object-oriented. The difference between functions and 
  methods in other languages is that functions do not have an associated 
  object. 

  One of Ruby's main advantages is the large number of built in methods.

  Creating a Method
    Syntax
      def my_name
        "Joe Smith"
      end

      puts my_name    #=> "Joe Smith"

    Naming Conventions
      snake_case

      Ruby has ~40 reserved words like end, while, for

      ?, !, =, can only go at the end of the name

      Cannot begin the name with a number

      If it feels like the method does too many things to give it a simple
      name, that is generally a sign that it should be broken up into 
      several smaller/simpler methods

  Parameters and Arguments - commonly used interchangably
    Parameters - variables (or placeholder for variables) that your 
    method receives when it is called

    Argument - actual variables that get passed to the method

    Default Parameters:
      def greet(name = "stranger")
        "Hello, " + name + "!"
      end

      puts greet("Jane") #=> Hello, Jane!
      puts greet #=> Hello, stranger!
  
  Optional Parentheses 
    Keep in mind that parentheses are optional when calling methods in 
    Ruby, say("Hi") is the same as say "Hi"

  Ways to call Methods
    1. some_method(obj) - send arguments (obj) to a method call
    2. a_caller.some_method(obj) - a_caller is called an explicit caller

  What methods return
    Implicit return - Methods in Ruby will return the output of the last 
    expression that was evaluated even without the return keyword

    Explicit return - using the return keyword will stop the method from 
    evalutating any further lines. 
      Useful for writing checks for input errors into your methods
        def even_odd(number)
          unless number.is_a? Numeric
            return "A number was not entered."
          end

          if number % 2 == 0
            "That is an even number."
          else
            "That is an odd number."
          end
        end

  Chaining Methods
    ex:
      phrase = ["be", "to", "not", "or", "be", "to"]

      puts phrase.reverse.join(" ").capitalize
      #=> "To be or not to be"

    You can also directly pass method calls as arguments to other methods.
    That's kinda what's happening here but this is an example of what it 
    looks like to pass the results of multiple methods to another:
      multiply(add(20, 45), subtract(80, 10))
      => 4550             *these aren't native methods*

  Predictate Methods - methods that return a boolean
    Usually denoted with a "?" at the end of the method name (not 
    enforced)

  Bang Methods - simultaneously perform their action and overwrite the 
  value of the original object with the result
    Dentoed with a "!" at the end of the method name

    Writing 
      string.downcase! 
    is the equivalent of writing 
      string = whisper.downcase

Debugging 
  p vs puts
    puts is good for debugging, but the drawback is that anything that 
    evaluates to nil or an empty string will just print a blank line to 
    the terminal

    Using p is the solution to this problem

  Pry Gem
    Pry is a Ruby Gem that lets you open an IRB-like session in your 
    terminal while your program is running. 

    To use, you have to include: require 'pry-byebug' at the top of your
    program

    Then the Pry-byebug will open whenever you call binding.pry in the 
    program.

    Once Pry is open, you can enter 'next' to step over to the next line

  Debug Gem
    Launch without configuration
      Without any configuration, you can use this debugger by 
      "Start Debugging" (F5 key) if you activate .rb file.

      You will see the "Debug command line" input dialog. Please specify 
      your favorite command line you want to debug.

      For example:

      ruby foo.rb (launch foo.rb)
      ruby foo.rb 10 20 30 (launch foo.rb with options 10, 20 and 30)
      rake taskA (launch rake task taskA)
      bundle exec rspec (launch rspec command with bundle exec)
      bin/rails s (launch bin/rails s)
      When you select a command line, the specified command will run on 
      rdbg debugger, and VSCode will connect to the rdbg debugger with 
      UNIX domain socket.

      And new terminal is created (named rdbg). You can see stdout/err 
      outputs and you can input stdin on rdbg terminal.

      You can stop the programs
      - by setting breakpoints (F9) on source code.
      - by exception (if you enable "rescue exception").
      - by pushing the Pause button (F6).
      
      When the program stops, you can see "Call stack", "Variables" and 
      you can set "Watch" expressions. On the debug console, you can input 
      valid Ruby program and you will get an evaluation result on selected 
      context ("Call stack").
  
Enumerables
  Enumerable Iterators Cheat Sheet
    - #each returns the original object it was called on because it's 
      really used for its side effects and not what it returns
    - #each_with_index passes not just the current item but whatever 
      position in the array it was located in.
    - #select returns a new object (e.g. array) filled with only those 
      original items where the block you gave it returned true
    - #map returns a new array filled with whatever gets returned by the 
      block each time it runs.

  docs - https://ruby-doc.org/core-3.1.2/Enumerable.html

  #select - iterate through array using a provided condition to filter 
  contents (also called #filter)
    Before #select:
      friends = ['Sharon', 'Leo', 'Leila', 'Brian', 'Arun']
      invited_list = []

      for friend in friends do
        if friend != 'Brian'
        invited_list.push(friend)
        end
      end

      invited_list #=> ["Sharon", "Leo", "Leila", "Arun"]

    With #select:
      friends = ['Sharon', 'Leo', 'Leila', 'Brian', 'Arun']

      friends.select { |friend| friend != 'Brian' }
      #=> ["Sharon", "Leo", "Leila", "Arun"]

    You can also use #select on hashes but you need to remember to set a 
    variable for the key and the value:
      responses = { 'Sharon' => 'yes', 'Leo' => 'no', 'Leila' => 'no', 'Arun' => 'yes' }
      responses.select { |person, response| response == 'yes'}
      #=> {"Sharon"=>"yes", "Arun"=>"yes"}
    
  #reject is a bit more to the point 
    friends.reject { |friend| friend == 'Brian' }

  #each - the main enumerable method, can do almost anything but not 
  always the best to use
    Will iterate through an array and feed each element to a code block

    Example:
      friends = ['Sharon', 'Leo', 'Leila', 'Brian', 'Arun']

      friends.each { |friend| puts "Hello, " + friend }

      #=> Hello, Sharon
      #=> Hello, Leo
      #=> Hello, Leila
      #=> Hello, Brian
      #=> Hello, Arun

      #=> ["Sharon", "Leo", "Leila", "Brian" "Arun"]

    What about when you need your code block to be more than one line
      do ... end 
        my_array = [1, 2]

        my_array.each do |num|
          num *= 2
          puts "The new number is #{num}."
        end

        #=> The new number is 2.
        #=> The new number is 4.

        #=> [1, 2]

    You can also use most of these methods with hashes
      my_hash = { "one" => 1, "two" => 2 }

      my_hash.each { |key, value| puts "#{key} is #{value}" }

      one is 1
      two is 2
      #=> { "one" => 1, "two" => 2}

      my_hash.each { |pair| puts "the pair is #{pair}" }

      the pair is ["one", 1]
      the pair is ["two", 2]
      #=> { "one" => 1, "two" => 2}

    You can see above that #each returns the original array/hash 
      Here's an example of how you can output an array of the modified 
      elements:
        friends = ['Sharon', 'Leo', 'Leila', 'Brian', 'Arun']
        shouting_at_friends = []

        friends.each { |friend| shouting_at_friends.push(friend.upcase) }
        #=> ['Sharon', 'Leo', 'Leila', 'Brian', 'Arun']

        shouting_at_friends #=> ['SHARON', 'LEO', 'LEILA', 'BRIAN', 'ARUN']

  #map - you can also use #map to do what was done above with #each 
    map will automatically return the transformed elements in a new 
    array 
      example:
        friends = ['Sharon', 'Leo', 'Leila', 'Brian', 'Arun']

        friends.map { |friend| friend.upcase }
        #=> `['SHARON', 'LEO', 'LEILA', 'BRIAN', 'ARUN']`

    #map + #gsub example:
      my_order = ['medium Big Mac', 'medium fries', 'medium milkshake']

      my_order.map { |item| item.gsub('medium', 'extra large') }
      #=> ["extra large Big Mac", "extra large fries", "extra large milkshake"]

    You can use #map.with_index if you need an index with your values 
      ex:
        array = %w(a b c)
        array.map.with_index { |ch, idx| [ch, idx] }
        # [["a", 0], ["b", 1], ["c", 2]]

  #reduce - reduces an array or hash down to a single object
    example - obtain a sum of an array of numbers
      with #each:
        my_numbers = [5, 6, 7, 8]
        sum = 0
        my_numbers.each { |number| sum += number }
        sum
        #=> 26

      with #reduce:
        my_numbers = [5, 6, 7, 8]
        my_numbers.reduce { |sum, number| sum + number }
        #=> 26

    The first block variable in the example above (sum) is called the 
    accumulator. The result of each iteration is stored in the accumulator 
    and then passed to the next iteration. #reduce will also return this 
    value after completion. 

    By default, the initial value of the accumulator will be the first 
    element in the input collection.  But you can also set a different 
    initial value for the accmulator by passing in a value to #reduce.
      my_numbers = [5, 6, 7, 8]
      my_numbers.reduce(1000) { |sum, number| sum + number }
      #=> 1026

    You can also set a Hash object as your accumulator. Here's an 
    example where this is used to analyze/summarize data:
      votes = ["Bob's Dirty Burger Shack", "St. Mark's Bistro", "Bob's 
      Dirty Burger Shack"]
      votes.reduce(Hash.new(0)) do |result, vote|
        result[vote] += 1
        result
      end
      #=> {"Bob's Dirty Burger Shack"=>2, "St. Mark's Bistro"=>1}

      hash.new(0) creates a new hash with an initial value of 0 that is 
      passed to #reduce as the intial value for the accumulator.

  Bang Methods
    add ! to the end of your method declaration to make it a bang method 
    which will cause it to overwrite the array that the method was called 
    on rather than creating a new array. (ex: #map!)

    Best practice is to avoid these methods unless necessary.

  Return Values of Enumerables
    Without using bang methods, you will need to assign your method 
    outputs to something.

    Option 1: local variable
      invited_friends = friends.select { |friend| friend != 'Brian' }

    Option 2: Wrap the enumerable in a method definition
      friends = ['Sharon', 'Leo', 'Leila', 'Brian', 'Arun']

      def invited_friends(friends)
        friends.select { |friend| friend != 'Brian' }
      end

      friends
      #=> ['Sharon', 'Leo', 'Leila', 'Brian', 'Arun']

      invited_friends(friends)
      #=> ["Sharon", "Leo", "Leila", "Arun"]

  Other Enumerables:
    #any? returns true/false (see the question mark?) and answers the 
      question, "do ANY of the elements in this object pass the test in my 
      block?". If your block returns true on any time it runs, any? will 
      return true.

    #all? is the same thing but will only return true if the block returns
      true for every element.

    #none? - u get the idea 

    #find - returns the first item in your object for which the block 
      returns true.

    #group_by will run your block and return a hash that groups all the 
      different types of returns from that block. For example:
      > names = ["James", "Bob", "Joe", "Mark", "Jim"]
      > names.group_by{|name| name.length}
      => {5=>["James"], 3=>["Bob", "Joe", "Jim"], 4=>["Mark"]} 

    #include?, #sort, #count

  Enumerable examples:
    Doubling numbers:
      array = [1,2,3]
      array.map { |n| n * 2 }
      # [2, 4, 6]

    Convert strings to integers:
      array = ["11", "21", "5"]
      array.map { |str| str.to_i }
      # [11, 21, 5]

    Convert hash values to symbols:
      hash = { bacon: "protein", apple: "fruit" }
      hash.map { |k,v| [k, v.to_sym] }.to_h
      # {:bacon=>:protein, :apple=>:fruit}

  Predicate enumerable methods
    Refresh: a predicate method is indicated by a question mark at the end 
    of the method name and returns either true or false.

    #include? - returns true if the element you pass as an argument exists 
    in the array or hash 
      numbers = [5, 6, 7, 8]
      numbers.include?(6)
      #=> true
      numbers.include?(3)
      #=> false

    #any? - returns true if any elements in the array or hash match the 
    conditions within the block
      numbers = [21, 42, 303, 499, 550, 811]
      numbers.any? { |number| number > 500 }
      #=> true
      numbers.any? { |number| number < 20 }
      #=> false

    #all? - same as any but will only return true if all elements match 
    the block conditions
      fruits = ["apple", "banana", "strawberry", "pineapple"]
      fruits.all? { |fruit| fruit.length > 3 }
      #=> true
      fruits.all? { |fruit| fruit.length > 6 }
      #=> false

      #all? will return true by default unless the block returns false or 
      nil, so calling #all? on an empty array or hash will result in true 

    #none? - true if no elements match the block conditions
      fruits = ["apple", "banana", "strawberry", "pineapple"]
      fruits.none? { |fruit| fruit.length > 10 }
      #=> true
      fruits.none? { |fruit| fruit.length > 6 }
      #=> false

Nested Arrays
  Useful to store groups of similar data or positional data

  Accessing Elements
    Accessing a specific element within a nested array is as simple as 
    calling array[x][y], where x is the index of the nested element and y 
    is the index inside of the nested element.

    If you try to access an index of a nonexistent nested element, it will 
    raise an NoMethodError, because the nil class does not have a [] 
    method. However, just like a regular array, if you try to access a 
    nonexistent index inside of an existing nested element, it will return 
    nil.
      teacher_mailboxes[3][0]
      #=> NoMethodError (nil[0] -> NoMethodError)
      teacher_mailboxes[0][4]
      #=> nil

    If you want a nil value returned when trying to access an index of a 
    nonexistent nested element, you can use the #dig method. This method 
    can also be used when accessing a nonexistent index inside of an 
    existing nested element.
      teacher_mailboxes.dig(3, 0)
      #=> nil
      teacher_mailboxes.dig(0, 4)
      #=> nil

  Creating a Nested Array
    Array.new needs to be called with a block to create a nested array, 
    trying to add an array as the default value for a new array will lead 
    to an array of pointers that all direct towards the same array. So 
    changing one of the nested arrays will change all of them. Using a 
    block calls Array.new() once per element in the encompassing array.

    Correct Syntax:
      immutable = Array.new(3) { Array.new(2) }
      #=> [[nil, nil], [nil, nil], [nil, nil]]
      immutable[0][0] = 1000
      #=> 1000
      immutable
      #=> [[1000, nil], [nil, nil], [nil, nil]]

  Adding and Removing Elements
    #push - my_array[0].push(100) will add 100 to the end of the first array 
    in my_array
      You can also use the shovel operator: my_array[0] << 100

    #pop - my_array[0].pop will remove 100 from the array (last element) 
    and return it

  Iterating over a Nested Array
    Here's an example where you are just iterating through the outside 
    array and referencing the nested arrays as rows
      teacher_mailboxes.each_with_index do |row, row_index|
        puts "Row:#{row_index} = #{row}"
      end
      #=> Row:0 = ["Adams", "Baker", "Clark", "Davis"]
      #=> Row:1 = ["Jones", "Lewis", "Lopez", "Moore"]
      #=> Row:2 = ["Perez", "Scott", "Smith", "Young"]

    To iterate over the individual elements inside of each row, you will 
    need to nest another enumerable method inside.
      teacher_mailboxes.each_with_index do |row, row_index|
        row.each_with_index do |teacher, column_index|
          puts "Row:#{row_index} Column:#{column_index} = #{teacher}"
        end
      end
      #=> Row:0 Column:0 = Adams, #=> Row:0 Column:1 = Baker
      #=> Row:0 Column:2 = Clark, #=> Row:0 Column:3 = Davis
      #=> Row:1 Column:0 = Jones, #=> Row:1 Column:1 = Lewis
      #=> Row:1 Column:2 = Lopez, #=> Row:1 Column:3 = Moore
      #=> Row:2 Column:0 = Perez, #=> Row:2 Column:1 = Scott
      #=> Row:2 Column:2 = Smith, #=> Row:2 Column:3 = Young
      #=> [["Adams", "Baker", "Clark", "Davis"], ["Jones", "Lewis", 
      "Lopez", "Moore"], ["Perez", "Scott", "Smith", "Young"]]

    If you only need the values and don't care about the indicies, you can 
    use #flatten:
      teacher_mailboxes.flatten.each do |teacher|
        puts "#{teacher} is amazing!"
      end
      #=> Adams is amazing!
      #=> Baker is amazing!
      #=> Clark is amazing! ... etc

  Nested Array Examples:
    Using any? and all?:
      test_scores.any? do |scores|
        scores.all? { |score| score > 80 }
      end

      This code would run through an array of arrays of test scores, and 
      return true if ANY of the score arrays contain values that are ALL 
      above 80.
  
Nested Hashes
  Nested hashes are a very common way to store complex associated data.
    vehicles = {
      alice: {year: 2019, make: "Toyota", model: "Corolla"},
      blake: {year: 2020, make: "Volkswagen", model: "Beetle"},
      caleb: {year: 2020, make: "Honda", model: "Accord"}
    }
  
  Accessing Data 
    hash[:x][:y], where :x is the key of the hash and :y is the key of the 
    nested hash.
      vehicles[:alice][:year]
      #=> 2019

    Similar to nested arrays, if you try to access a key in a nonexistent 
    nested hash, it will raise an NoMethodError, therefore you may want to 
    use the #dig method
  
  Adding and Removing Data
    You can add a new nested hash just like you would expect:
      vehicles[:dave] = {year: 2021, make: "Ford", model: "Escape"}

    You can also add an element to a single nested hash like this:
      vehicles[:dave][:color] = "red"

    You can delete a nested hash like this:
      vehicles.delete(:blake) (returns deleted nested hash)

    You can delete a specific key-value pair from a nested hash like this: 
      vehicles[:dave].delete(:color)

  Methods 
    Example: find who owns a vehicle from 2020 or newer
      vehicles.select { |name, data| data[:year] >= 2020 }
      This would return the entire nested hash though...
    What if you only want the name and not the whole hash?
    #collect can do that
      vehicles.collect { |name, data| name if data[:year] >= 2020 }
      #=> [nil, :caleb, :dave]

      returns the value of each iteration, so iterations when the block 
      results in false will return nil
        #compact will return an array or hash without nil values
          vehicles.collect { |name, data| name if data[:year] >= 2020 }.compact
          #=> [:caleb, :dave]
      
        You can also do this with #filter_map
          vehicles.filter_map { |name, data| name if data[:year] >= 2020 }
          #=> [:caleb, :dave]

Classes / Modules
  Classes vs Modules 
    Modules are packages of methods that can be loaded into classes. 
    Classes can also be collections of methods, so what's the difference?
      Firstly, a class is much more than a module, it can hold it's state,
      be instantiated, duplicated, hold countless objects and other classes.

      The main difference that makes modules useful is that they can never 
      be instantiated. It will never be anything other than a collection of
      methods that can be called when loaded in.

  Example to explain:
    module Speak
      def speak(sound)
        puts sound
      end
    end

    class GoodDog
      include Speak
    end

    class HumanBeing
      include Speak
    end

    sparky = GoodDog.new
    sparky.speak("Arf!")        # => Arf!
    bob = HumanBeing.new
    bob.speak("Hello!")         # => Hello!

  Classes
    Classes are used to create objects.

    Two things are typically focused on when created classes, state and 
    behaviors.
      State - data associated with the individual object
        Tracked by instance variables, which are scoped at the object level 
      Behaviors - what the objects are capable of doing 

    Initializing a new object
      #initialize - this method gets called every time you create a new 
      object. 

      Example:
        class GoodDog
          def initialize
            puts "This object was initialized!"
          end
        end

        sparky = GoodDog.new    # => "This object was initialized!"

    Instance Variables 
      class GoodDog
        def initialize(name)
          @name = name  # @name here creates an Instance Variable, it can 
          be referenced until the object instance is destroyed. 
        end
      end

      sparky = GoodDog.new("Sparky") # passes "Sparky" from #new to 
      #initialize and is assigned to the local variable name. Then @name
      is set to name. 

    Instance Methods
      You can define methods within classes as well 

      Example
        class GoodDog
          def initialize(name)
            @name = name
          end

          def speak
            "Arf!"
          end
        end

        sparky = GoodDog.new("Sparky")
        sparky.speak # this would actually do nothing since "Arf!" is 
        returned but not printed

    Accessor Methods 
      Getting variables
        Use a normal method like you would expect:
          def get_name
            @name
          end
          sparky = GoodDog.new("Sparky")
          puts sparky.get_name   # => "Sparky"
      
      Setting variables
        Slightly different:
          def set_name=(name)
            @name = name
          end
          sparky.set_name = "Spartacus"
          puts sparky.get_name     # => "Spartacus"

      It is common practice to name these methods the same:
        def name
          @name
        end
        def name=(name)
          @name = name
        end
        sparky.name = "Scoot"
        puts sparky.name    # => "Scoot"
    
      #attr_accessor - takes a symbol as an input that is used to create 
      the method name for the getter and setter methods
        #attr_reader - only creates getter 
        #attr_writer - only creates setter

        Example:
          class GoodDog
            attr_accessor :name

            def initialize(name)
              @name = name
            end

            def speak
              "#{@name} says arf!"
            end
          end

          sparky = GoodDog.new("Sparky")
          puts sparky.speak
          puts sparky.name            # => "Sparky"
          sparky.name = "Spartacus"
          puts sparky.name            # => "Spartacus"

        Usually you would change your other methods defined within the 
        class to use these intance methods as well rather than directly 
        referencing the instance variables
          For example, #speak could be rewritten to this:
            def speak
              "#{name} says arf!"
            end
        
        This lets you save a lot of space with multiple instance variables:
          class Person
            attr_accessor :name, :height, :weight

            def initialize(name, height, weight)
              @name = name
              @height = height
              @weight = weight
            end
          end

        If you want to use these getter/setter methods in other methods 
        within the class, you can use self.name= :
          def change_info(n, h, w)
            self.name = n
            self.height = h
            self.weight = w
          end

    Class Methods
      Methods that are called directly on a class itself 

      Example:
        def self.what_am_i         # Class method definition
          "I'm a GoodDog class!"
        end
        GoodDog.what_am_i          # => I'm a GoodDog class!
      
      Class Methods are for any functionality that does not pertain to 
      individual objects

    Class Variables
      Example:
        class GoodDog
          @@number_of_dogs = 0

          def initialize
            @@number_of_dogs += 1   # When a new object is added to the class it increases the class variable
          end

          def self.total_number_of_dogs
            @@number_of_dogs   # defines class method to return class variable
          end
        end

        puts GoodDog.total_number_of_dogs   # => 0

        dog1 = GoodDog.new
        dog2 = GoodDog.new

        puts GoodDog.total_number_of_dogs   # => 2

      Class variables are defined with 2 @'s. This example shows how you 
      can use class variables and methods to keep track of class level 
      data that pertains only to the class, and not to individual objects 

    Constants 
      If you have a class level variable that never needs to change, you 
      can define it as a constant variable like this: (DOG_YEARS)
        class GoodDog
          DOG_YEARS = 7

          attr_accessor :name, :age

          def initialize(n, a)
            self.name = n
            self.age  = a * DOG_YEARS
          end
        end

        sparky = GoodDog.new("Sparky", 4)
        puts sparky.age             # => 28

      Constants have to start with a capital letter but good practice is 
      to captialize the whole word. 

    The to_s method
      this instance method is built in to every class in Ruby, it is 
      automatically called whenever you call'puts sparky' for example

      Output without defining to_s:
        puts sparky      # => #<GoodDog:0x007fe542323320>

        returns the name of the object's class and an encoding of the
        object id

      You can also define your own code block to run for to_s:
        class GoodDog
          DOG_YEARS = 7

          attr_accessor :name, :age

          def initialize(n, a)
            @name = n
            @age  = a * DOG_YEARS
          end

          def to_s
            "This dog's name is #{name} and it is #{age} in dog years."
          end
        end
        puts sparky  # => This dog's name is Sparky and is 28 in dog years.

        Needs to return a string though, otherwise will search up the 
        inheritance chain for another verion of #to_s

      Calling p will automatically call the inspect method which returns this:
        p sparky   # => #<GoodDog:0x007fe54229b358 @name="Sparky", @age=28>
      
    Self
      Uses:
        Calling instance methods from within their class. 
          Calling self.name= acts the same as calling sparky.name= from 
          outside the class. You can't call sparky.name= inside the class 
          because it is not within the scope. 
        
        Defining a class method
          def self.method is the same as def ClassName.method but if you 
          use the second version and end up wanting to change the class 
          name, you would have to change every class method definition 

    ChatGPT Class Exercise Prompts
      Bank Account Management:
        Create a BankAccount class that allows you to create and manage 
        bank accounts. The class can have methods for depositing, 
        withdrawing, checking the balance, and displaying account 
        information. You can also have a separate Transaction class 
        to record and manage transactions.

        Completed: bank_management.rb

      Library Management:
        Create a Library class that manages books and patrons. 
        You can have separate classes for Book and Patron. The Library 
        class can handle checking out, returning, and displaying book 
        information.

      Inventory Management:
        Create an Inventory class for managing products in a store. You 
        can have separate classes for Product and Supplier. The Inventory 
        class can handle adding, removing, and updating product 
        information.

  Modules 
    Modules are used to mix behaviors between classes that may not follow 
    the same natural hierarchical model that the general classes themselves 
    follow. For example, let's say you define a class Animal with subclasses 
    Mammal and Fish, and further subclasses under those for specific animals.
    You may want to add #swim to Fish, because most Animals in the Fish 
    class will need to swim. But there are a lot of mammals who also swim and 
    would need access to this method. Not all Animals swim so we don't want
    to move it there, but we also don't want to recreate #swim in each 
    Mammal subclass. 
      Example:
        module Swimmable
          def swim
            "I'm swimming!"
          end
        end

        class Animal; end

        class Fish < Animal
          include Swimmable         # mixing in Swimmable module
        end

        class Mammal < Animal
        end

        class Cat < Mammal
        end

        class Dog < Mammal
          include Swimmable         # mixing in Swimmable module
        end
    
    Syntax convention: use the "able" suffix on whatever verb describes the
    behavior that the module is modeling. e.g: Swimmable for #swim

    Namespacing - Module Classes
      Similar classes can be defined within a module to keep them organized.

      These classes are used like this: with Mammal being the module and 
      Dog/Cat being classes within the module.
        buddy = Mammal::Dog.new
        kitty = Mammal::Cat.new
    Module Methods
      Modules can also be used as a container for methods. This is commonly 
      used for methods that do not have a clear home within other Classes or
      Objects. 

      Example of defining a method within a module:
        module Mammal
          ...

          def self.some_out_of_place_method(num)
            num ** 2
          end
        end
      
      methods within modules are calling like this:
        value = Mammal.some_out_of_place_method(4)
      
  Method Access Control - Private, Protected, Public
    Public - Methods are public by default, available to anyone who knows 
    either the class name or the object's name

    Private - Sometimes you need methods that do work within a class but 
    should not be or do not need to be accessible to the rest of the program.
      Private methods are only accessible from other methods in the class

      Anything below a #private call will be private, so if you want to
      return to public methods you need to call #public.

      Example:
        class GoodDog
          DOG_YEARS = 7

          attr_accessor :name, :age

          def initialize(n, a)
            self.name = n
            self.age = a
          end

          private

          def human_years
            age * DOG_YEARS
          end
        end

        sparky = GoodDog.new("Sparky", 4)
        sparky.human_years

        NoMethodError: private method `human_years' called for
        #<GoodDog:0x007f8f431441f8 @name="Sparky", @age=4>
    
    Protected - Cannot be called from outside the class, but allow access 
    between class instances
      Exampe:
        class Person
          def initialize(age)
            @age = age
          end

          def older?(other_person)
            age > other_person.age
          end

          protected

          attr_reader :age
        end

        malory = Person.new(64)
        sterling = Person.new(42)

        malory.older?(sterling)  # => true
        sterling.older?(malory)  # => false

        malory.age
          # => NoMethodError: protected method `age' called for #<Person: @age=64>
        
      The above code shows us that like private methods, protected methods 
      cannot be invoked from outside of the class. However, unlike private 
      methods, other instances of the class (or subclass) can also invoke 
      the method. This allows for controlled access, but wider access 
      between objects of the same class type.

Inheritance
  Inheritance is when a class inherits behavior from another class. The 
  class that is inheriting behavior is called the subclass and the class 
  it inherits from is called the superclass.

  Syntax
    Class MyClass < SubClass
    SubClass.superclass  # => SubClass

  Class Inheritance
    Example: extracting #speak from GoodDog class (prior example) to 
    superclass Animal, then using inheritance to make that behavior 
    available in the GoodDog and Cat classes.
      class Animal
        def speak
          "Hello!"
        end
      end

      class GoodDog < Animal
      end

      class Cat < Animal
      end

      sparky = GoodDog.new
      paws = Cat.new
      puts sparky.speak           # => Hello!
      puts paws.speak             # => Hello!

    What if you want the GoodDog class to use its own #speak:
      class Animal
        def speak
          "Hello!"
        end
      end

      class GoodDog < Animal
        attr_accessor :name

        def initialize(n)
          self.name = n
        end

        def speak
          "#{self.name} says arf!"
        end
      end

      class Cat < Animal
      end

      sparky = GoodDog.new("Sparky")
      paws = Cat.new

      puts sparky.speak           # => Sparky says arf!
      puts paws.speak             # => Hello!

      Ruby will check the object's class before looking in the superclass.

    Encapsulation
      If you are establishing a new class that you want to inherit methods 
      from an existing class, you can also created a nested class. 

      Nested Classes are just classes that are defined within the 
      definition of another class. It is similar to a subclass except that
      it is encapsulated within it's container (the class it is defined 
      within)

  super - keyword that searches the method lookup path for a method with 
  the same name and invokes it. 
    Example: 
      class Animal
        def speak
          "Hello!"
        end
      end

      class GoodDog < Animal
        def speak
          super + " from GoodDog class"   # calls speak from Animal and adds a string
          # => "Hello! from GoodDog class"
        end
      end

    Important use: If you want a class to copy its parent's initialize 
    method with a few tweaks
      def initialize(name, health, age, strength, weapon)
          super(name, health, age, strength)
          @weapon = weapon
      end

      sparky = GoodDog.new
      sparky.speak        # => "Hello! from GoodDog class"
    
    A common use for super is in initialize methods:
      class Animal
        attr_accessor :name

        def initialize(name)
          @name = name
        end
      end

      class GoodDog < Animal
        def initialize(color)
          super
          @color = color
        end
      end

      bruno = GoodDog.new("brown")        # => #<GoodDog:0x007fb40b1e6718 @color="brown", @name="brown">

      class BadDog < Animal
        def initialize(age, name)
          super(name)
          @age = age
        end
      end

      BadDog.new(2, "bear")        # => #<BadDog:0x007fb40b2beb68 @age=2, @name="bear">

      The first GoodDog example doesn't work as intended because it passes 
      "brown" to @name as well as @color. BadDog works as intended because
      it takes two arguments.

      If you want (or need) to call an initialize method (or any inherited 
      method) with no arguments, you need to use super() with parantheses.
        Example: 
          class Animal
            def initialize
            end
          end

          class Bear < Animal
            def initialize(color)
              super()
              @color = color
            end
          end

          bear = Bear.new("black")        # => #<Bear:0x007fb40b1e6718 @color="black">

          If you forget to use the parentheses here, Ruby will raise an 
          ArgumentError exception since the number of arguments is 
          incorrect.
  
  Module Inheritance - mixins
      The order in which you include modules is important to the method 
      lookup path.

      Ruby will look at the last module included first. So if there are 
      methods with the same name, it will use the method from the last 
      module mixed in.

      Another important thing to note is that methods from modules included 
      in classes will be accessible by their subclasses as well.

      Understanding the method lookup path is important when working on 
      large projects. 

  When to use class inheritance vs mixins. Here are a couple of things to 
  consider when evaluating these choices.
    You can only subclass (class inheritance) from one class. You can mix 
    in as many modules (interface inheritance) as you'd like.

    If there's an "is-a" relationship, class inheritance is usually the 
    correct choice. If there's a "has-a" relationship, interface 
    inheritance is generally a better choice. For example, a dog "is an" 
    animal and it "has an" ability to swim.

    You cannot instantiate modules. In other words, objects cannot be 
    created from modules.

  Accidental Method Overriding
    Remember that every class inherently subclasses from class Object. So 
    as you created classes and subclasses you may accidentally overwrite 
    methods originally defined in the Object Class since your classes will
    come first in the method lookup path. 
  
Error Handling
  begin/rescue block - used when you anticipate errors 
    basic example:
      a = 10
      b = "42"

      begin
        a + b 
      rescue 
        puts "Could not add variables a (#{a.class}) and b (#{b.class})"
      else 
        puts "a + b is #{a + b}"
      end

    more detailed example:
      require 'open-uri'
      require 'timeout'

      remote_base_url = "http://en.wikipedia.org/wiki"

      start_year = 1900
      end_year = 2000

      (start_year..end_year).each do |yr|
      begin
        rpage = open("#{remote_base_url}/#{yr}")
      rescue StandardError=>e   
      # the StandardError=>e specifies the type of error that should cause this rescue block to run
      # the actual error gets stored in e
        puts "Error: #{e}"
      else # code that runs if no error
        rdata = rpage.read
      ensure   # code that runs regardless of error or no error
        puts "sleeping"
        sleep 5
      end
          
      if rdata
        File.open("copy-of-#{yr}.html", "w"){|f| f.write(rdata) }
      end
      end  

      You can also use the `retry` statement which redirects the program 
      back to the begin statement. 
        good to put this in an if statement that is counting number of retries

        need to be careful because nothing below retry will run if it is called

      You can also use `raise` to create your own Exception (similar to error but different)
      for testing purposes or whatever.

  Exception and Error Classes
    All errors are defined under the Exception class
      Exception family tree: http://ruby.bastardsbook.com/chapters/exception-handling/#exception-tree 

    Often you will want to specify the type of error you want to rescue, 
    not doing so can lead to adverse effects. For example, if you run code 
    that ends up requiring you to use cmd + c to break out, but you have a 
    rescue block that is set to catch any Exception, it won't let you break
    out because cmd + c uses an Interrupt exception which is defined under 
    the Exception class.

    StandardError covers just about any kind of syntax type error, usually 
    this is what you're looking for. You can get even more specific within 
    that if needed.



    

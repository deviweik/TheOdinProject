irb - type irb in console to open Interactive Ruby, lets you interactively
execute Ruby code and see the results immediately.

Syntax
  tab - 2 spaces

  comments - `# this is a comment`

  always use snake_case for variables, methods, and files

  Use PascalCase (camelCase with first word capitalized as well) for 
  declaring class names

  semicolons are never required in Ruby, but they allow you to write 
  multiple lines of code on one line.

  Constant variables - all caps 
    FOUR = 'four'
    FIVE = 5

  puts vs return
    Every expression (pretty much anything written in Ruby) will return 
    something. It may return an error or nil, but it will return something.

    puts - telling Ruby to print something to the screen, but puts will not 
    return that value. It returns nil instead
      ex:
        > a = puts "stuff"
        "stuff"
        => nil
        > puts a 
        # blank space here from printing `nil`
        => nil

  Tips on reading documentation pages:
    https://launchschool.com/books/ruby/read/preparations#usingacodeeditor
  
Data Types
  Numbers, Strings, Symbols, Booleans, Literals, Basic Data Structures (
  arrays, hashes)

  Numbers 
    Operators
      +, -, *, /, modulus: %, exponent: **

      Equality - Ruby uses `==` for equality comparisions, returns T/F
        Like === in JS, == in Ruby will return false if the operands' types
        are different, ex: '4' == 4 => false

    Number Types
      Integers: whole Numbers
        arithmetic with integers will always result in an integer
      Floats: decimals

      Converting Number Types
        # To convert an integer to a float:
        13.to_f   #=> 13.0

        # To convert a float to an integer:
        13.0.to_i #=> 13
        13.9.to_i #=> 13
        # As shown here, it will simply cut off the decimal, no rounding

        Some interesting details on string -> number conversions
          irb :001 > '4'.to_i
          => 4

          irb :002 > '4 hi there'.to_i
          => 4

          irb :003 > 'hi there 4'.to_i
          => 0

          irb :004 > '4'.to_f
          => 4.0

          irb :005 > '4 hi there'.to_f
          => 4.0

          irb :006 > 'hi there 4'.to_f
          => 0.0
      
    Number Methods 
      #even? and #odd?
        6.even? # => true
        6.odd? # => false

      Remainder Methods
        #remainder - computes and returns the remainder of an integer 
        division operation
          16.remainder(5) => 1
        
        #divmod - computes both the integer result and the modulo value
          16.divmod(5) => [3,1]

        Modulo vs remainder operations
          Modulo - returns a positive integer when the 2nd operand is 
          positive, and a negative integer when the 2nd operand is negative

          Remainder ops- return a + integer when the 1st operand is +, a 
          - integer when the 1st operand is negative.

          Only matters if you need to use negative integers with these 
          functions for some reason, so best practice is to try to only
          use positive integers if possible.
    
  Strings
    Syntax
      Like JS, can use single or double quotation marks
      Difference: string interpolation and escape characters will only work
      inside double quotation marks

    Concatenation
      # With the plus operator:
      "Welcome " + "to " + "Odin!"    #=> "Welcome to Odin!"

      # With the shovel operator:
      "Welcome " << "to " << "Odin!"  #=> "Welcome to Odin!"

      # With the concat method:
      "Welcome ".concat("to ").concat("Odin!")  #=> "Welcome to Odin!"

      Note: adding numbers as strings will result in string concatenation 
        '1' + '1' => '11'

      Unlike JS, you cannot add a number to a string or vice versa.
        'one' + 1 => error
        1 + 'one' => error
        1 + '1' => error
        1 + '1'.to_i => 2
        1.to_s + '1' => "11"

    Substrings
      "hello"[0]      #=> "h"

      "hello"[0..1]   #=> "he"

      "hello"[0, 4]   #=> "hell"

      "hello"[-1]     #=> "o"

    Escape Characters 
      \\  #=> Need a backslash in your string?
      \b  #=> Backspace
      \r  #=> Carriage return, for those of you that love typewriters
      \n  #=> Newline. You'll likely use this one the most.
      \s  #=> Space
      \t  #=> Tab
      \"  #=> Double quotation mark
      \'  #=> Single quotation mark

    Interpolation - evaluating strings with placeholder variables
      name = "Odin"

      puts "Hello, #{name}" #=> "Hello, Odin"
      puts 'Hello, #{name}' #=> "Hello, #{name}"

    String Methods
      #capitalize
        "hello".capitalize #=> "Hello"

      #include?
        "hello".include?("lo")  #=> true

        "hello".include?("z")   #=> false
      
      #upcase
        "hello".upcase  #=> "HELLO"

      #downcase
        "Hello".downcase  #=> "hello"

      #empty?
        "hello".empty?  #=> false

        "".empty?       #=> true

      #length
        "hello".length  #=> 5

      #reverse
        "hello".reverse  #=> "olleh"

      #split
        "hello world".split  #=> ["hello", "world"]

        "hello".split("")    #=> ["h", "e", "l", "l", "o"]

      #strip
        " hello, world   ".strip  #=> "hello, world"

      These are only a few examples, here are some more to show the 
      possibilities with ruby:
        "he77o".sub("7", "l")           #=> "hel7o"

        "he77o".gsub("7", "l")          #=> "hello"

        "hello".insert(-1, " dude")     #=> "hello dude"

        "hello world".delete("l")       #=> "heo word"

        "!".prepend("hello, ", "world") #=> "hello, world!"

    Converting other objects to strings
      5.to_s        #=> "5"

      nil.to_s      #=> ""

      :symbol.to_s  #=> "symbol"
  
  Symbols
    Basically, strings are data types that store a collection of characters 
    that can be changed. So every time a string is used, Ruby has to store
    it in memory, even if that same string has already been stored 
    somewhere else. Symbols differ from strings in that they are only 
    stored in memory once, which can greatly increase performance in some
    cases. 
    
    Here is some code displaying this difference:
      "string" == "string"  #=> true

      "string".object_id == "string".object_id  #=> false

      :symbol.object_id == :symbol.object_id    #=> true

    An example of where symbols are preferred is for keys in hashes.

    Symbols are created by putting a colon at the beginning of some text:
      `:my_symbol`

  Booleans
    True and False 
      these are true and false, very standard

    Nil 
      In Ruby, nil = nothing

      Everything in Ruby will have a return value, so when any code has
      nothing to return, it will return `nil`.

      You can check if something is a nil type using .nil?
        "Hello, World".nil? => false

      When used in an expression, nil will be treated as false
        Despite this, false == nil => false

  Literals - any notation that represents a fixed value in source code
    examples:
      'Hello, world!'          # string literal
      375                      # integer literal
      3.141528                 # float literal
      true                     # boolean literal
      { 'a' => 1, 'b' => 2 }   # hash literal
      [ 1, 2, 3 ]              # array literal
      :sym                     # symbol literal
      nil                      # nil literal

  Basic Data Structures (Array/Hashes introduction)
    Arrays
      Syntax - array literal denoted by square brackets `[]`, comma-separated

      Ruby indexes from 0: [1,2,3,4,5][0] => 1

    Hashes - a hash is a set of key-value pairs
      Syntax - hash literal denoted by curly braces `{}`

      irb :001 > {:dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
      => "meows"

Variables 
  variable names are always reusable
  age = 18 => 18
  age = 18 + 5 => 23
  age += 5 => 28 (can also use -=, *=, /=)
  
  Variable naming
    Ruby was created to read and write as naturally as possible, so var 
    names should describe what the variable represents as clearly as 
    possible.

    snake_case

  Variables are references to a location in your computers memory
    This can lead to some unexpected results
      ex:
        string_location = "here"
        copy_location = string_location
        string_location.upcase!

        string_location => "HERE"
        copy_location => "HERE"

        string_location = "moved over there"
        copy_location => "HERE" 
          # changing the first var to reference a new place in comp's 
          # memory will not change the reference stored in second var

        Be careful assigning variables to other variables
  
  Getting Data from a User 
    gets - "get string"

    irb(main):008:0> name = gets
    Devin
    => "Devin\n"    

    irb(main):009:0> name = gets.chomp
    Devin
    => "Devin"  #chomp method can remove the new line

  Variable Scope 
    Blocks - blocks are pieces of code that follow a method's invocation
      ex:
        total = 0
        [1, 2, 3].each { |number| total += number }
        puts total # 6
        # the block here is inside the curly braces {}
          common practice is to use {} for one liners, 
          do |var| ... end for more

        total = 0
        [1, 2, 3].each do |number|
          total += number
        end
        puts total # 6
        # the block here is: do |number| ... end

      Variables defined outside the block (total) can be used inside the
      block, but any variables defined inside the block (number) cannot be
      used outside of the block. 
        Overall: Inner scope can access vars from outer scope, but not 
        vice versa.

  Variable Types
    Constants - created by capitalizing every letter in the var name
      note: constants can be reassigned in Ruby, but it will throw a 
      warning to let you know there was a previous definition

    Global Variables - available throughout the whole app, overriding all
    scope boundaries
      Defined by adding a $ before the var name
        $var = "global var"

      Generally avoided because they can lead to unexpected complications

    Class Variables - accessible by instances of your class, as well as 
    the class itself.
      Used when you need to declare a var that is related to a class, but
      each instance of that class does not need its own value for the var

      declared with two @ symbols before the var name
        @@instances = 0

    Instance Variables - Available throughout the current instance of the
    parent class.
      Declared with one @ symbol before the var name
        @var = 'instance var'

    Local Variables - most common, obey all scope boundaries

Inputs and Outputs
  Outputs
    print vs puts
      both output to irb/ REPL environment or into the command line and 
      return nil

      The difference is that puts will append a new line (\n) to the end of
      the output, while print will not.

    puts
      puts will attempt to convert everything into a string 
      (by calling to_s).
        important because if you’re trying to puts an array with nil 
        values it will show some blanks lines
          Example:
            puts [1,nil,nil,2]
            1

            
            2
          
      puts has a shorthand `p`
        puts "Hello, World!" is basically the same as:
        p "Hello, World!"

        there are some differences though:
          irb(main):008:0> puts "Hello"
          Hello
          => nil                                                         
          irb(main):009:0> p "Hello"
          "Hello" 
          => "Hello"
            # p will also show things like escape characters that 
          would not otherwise be clearly visible (useful for debugging)
  
    putc - only prints one character (the first) but returns the whole
    string.

  Inputs
    gets - causes program execution to stop and wait for user input, 
    continues after the user presses enter

    Unlike print/puts, gets will return what it outputs instead of just 
    returning nil

    gets also appends a new line (\n) to the end of whatever you input. 
    (the value that gets returns also has the \n)

    Full example of getting an input:
      puts "Enter a value :"
      val = gets
      puts val

      This will produce the following result −
      Enter a value :
      This is entered value
      This is entered value

Conditionals in Ruby 
  false
    Ruby only reads `nil` and `false` as falsy values
      Unlike other languages, 0 or empty strings ("") won't read as false

  if statement
    Syntax:
      if statement_to_be_evaluated == true
        # do something here...
      elsif another_statement_to_be_evaluated == true
        # do something else here...
      else
        # do something else here..
      end
    
    If there's only one line in the block of code you can write it this
    way:
      puts "example" if 1 < 2

  Boolean Logic
    equals ( == )

    not equal ( != )

    greater than ( > ) or equal to ( >= )

    less than ( < ) or equal to ( <= )

    #eql? - checks value type and actual value
      5.eql?(5.0) => false  # 5 is integer, 5.0 is float
      5.eql?(5) => true

    #equal? - checks if values are the exact same object in memory
      This has some interesting complications:
        Integers
          Computers store integers in memory differently
            a = 5
            b = 5
            a.equal?(b) #=> true
      
      Example:
        a = "hello"
        b = "hello"
        a.equal?(b) #=> false

    Spaceship operator 
      This is a unique operator that doesn't return true/false, instead it
      returns three numberical values

      Example:
        5 <=> 10    #=> -1    (-1 when left is less than right)
        10 <=> 10   #=> 0     (0 when left is equal to the right)
        10 <=> 5    #=> 1     (1 when left is greater than right)

      Most commonly used in sorting functions

  Logical Operators
    and (&&), or (||), not (!)
      Short circuit evaluation
        && and || will not evaluate the second expression if the first does
        not meet their criteria.
          If the first expression in an && operator evaluates to false, it
          will not even check the second.

          If the first expression in an || operator evaluates to true, it 
          will not check the second expression.

  Case Statements (like switch)
    ex: 
      grade = 'F'

      did_i_pass = case grade #=> create a variable `did_i_pass` and assign
      the result of a call to case with the variable grade passed in
        when 'A' then "Hell yeah!"
        when 'D' then "Don't tell your mother."
        else "'YOU SHALL NOT PASS!' -Gandalf"
      end

    If you have more complex code, just remove the `then` and put the code
    on the next line.
      ex: 
        grade = 'F'

        case grade
        when 'A'
          puts "You're a genius"
          future_bank_account_balance = 5_000_000
        when 'D'
          puts "Better luck next time"
          can_i_retire_soon = false
        else
          puts "'YOU SHALL NOT PASS!' -Gandalf"
          fml = true
        end

  Unless Statement 
    Works in the opposite way as an if statement, only processes the code
    if the statement evaluates to false
    
    age = 19
    puts "Welcome to a life of debt." unless age < 18

    unless age < 18
      puts "Down with that sort of thing."
    else
      puts "Careful now!"
    end

  Ternary Operator 
    Syntax
      conditional statement ? <execute if true> : <execute if false>

Loops in Ruby
  `loop` - Ruby has a loop initiated with `loop` that will continue 
  looping until you specifically tell it to stop with `break`
    Example for syntax:
      i = 0
      loop do
        puts "i is #{i}"
        i += 1
        break if i == 10
      end

    In general, this loop is not really used, if you are using it, there's
    probably a better solution available.

  While loop
    Example for syntax:
      i = 0
      while i < 10 do
        puts "i is #{i}"
        i += 1
      end
    
    Like `loop` loop except more readable with the break condition 
    declared in the initializer

    One common use case is repeatedly prompting a question until an 
    acceptable answer is provided:
      while gets.chomp != "yes" do
        puts "Will you go to prom with me?"
      end
    
  Until Loop
    Example for syntax:
      i = 0
      until i >= 10 do
        puts "i is #{i}"
        i += 1
      end
    
    This is the opposite of a while loop, it will continue as long as the
    provided conditional statement evaluates to false

    This makes them relatively interchangable. Ultimately the better one
    to use is dictated by the break condition; if you find yourself using
    a while loop with a `!` to negate the condition, it makes more sense
    to just use an until loop.

  Ranges
    Ranges can be used like for loops in matlab(/python maybe?) where you 
    loop over an array, but it's honestly not very similar to that syntax/
    usage wise.

    You can make the ranges inclusive or exclusive:
      Inclusive: (1..5) #=> 1, 2, 3, 4, 5 
      Exclusive: (1...5) #=> 1, 2, 3, 4

      You have to use other looping methods to actually implement these in
      a looping application:
        ex 1 - for:
          for n in 1..5
            puts n
          end
        
        ex 2 - each:
          (1..5).each do |n|
            puts n
          end

        These will both output:
          1
          2
          3
          4
          5
        
    You can also make ranges with letters: ('a'..'z') => 'a', 'b', ... 'z'

  For Loop
    Example for syntax:
      for i in 0..5
        puts "#{i} zombies incoming!"
      end

  Times Loop  (`#times` loop)
    Example for syntax:
      5.times do
        puts "Hello, world!"
      end

    IMPORTANT: all loops will start counting from 0
    (also you can access the current iteration number like below)
      so this code:
        3.times do |n|
          puts n
        end
      
      would output:
        0
        1
        2

  Upto and Downto Loops
    #upto - iterate from start # up to another #
    #downto - iterate from start # down to another #

    Syntax examples:
      5.upto(10) {|num| print "#{num} " }     #=> 5 6 7 8 9 10

      10.downto(5) {|num| print "#{num} " }   #=> 10 9 8 7 6 5
  
  Keywords
    break - exits the loop whenever executed, usually blocked inside 
    conditional statement

    next - skips the rest of the current iteration and continues with the
    next.
      ex:
        (1..10).each do |n|
          next if n % 2 == 0
          puts n
        end
      
    redo - repeats current iteration from the beginning
      ex:
        i = 0
        while i < 5
          i += 1
          redo if i == 3
          puts i
        end

    retry - restarts the entire loop from the beginning
      ex: 
        i = 0
        while i < 5
          begin
            i += 1
            raise if i == 3
            puts i
          rescue
            retry
          end
        end

        This example also uses other keywords `raise` and `rescue`
        Raise raises an exception, which is caught by the rescue block, 
        which then calls retry to restart from the beginning

    Here's another example that shows how raise and rescue can be used:
      (thanks chatGPT)

      def divide(numerator, denominator)
        raise ZeroDivisionError, "Cannot divide by zero" if denominator == 0
        numerator / denominator
      rescue ZeroDivisionError => e
        puts "Error: #{e.message}"
      end

      puts divide(10, 0) # Outputs "Error: Cannot divide by zero"

Arrays
  Syntax
    num_array = [1, 2, 3, 4, 5]
    str_array = ["This", "is", "a", "small", "array"]

  Creating Arrays
    [] - creating an array this way is called an 'array literal'

    Array.new - method to create an array
      you can also include up to 2 optional arguments 
      (initial size and default value):
        Array.new               #=> []
        Array.new(3)            #=> [nil, nil, nil]
        Array.new(3, 7)         #=> [7, 7, 7]
        Array.new(3, true)      #=> [true, true, true]

    Arrays use 0-based indexing in Ruby

    Attempting to index an invalid position results in 'nil'

    Arrays can also take negative indices which start from the end of an 
    array, starting with [-1]

    #first and #last methods - returns a new array containing the first or
    last n elements of the array
      myArray.first(n) -> new array with first n elements of myArray

  Adding/Removing from Arrays
    #push - can take multiple inputs and returns a new array with those 
    inputs appended.

    << shovel operator - appends one element to the end of your array
      myArray = [1,2]
      myArray << 3 => [1, 2, 3]

      You can also add more than 1 element by using the splat operator (*)
      before the input array to split it into individual elements:
        num_array = [1, 2]
        num_array << *[3, 4, 5] => [1, 2, 3, 4, 5]

    #pop - removes the element at the end of the array and returns the 
    element that was removed:
      num_array.pop => 5
      num_array => [1, 2, 3, 4]

    #shift - remove from the beginning of an array
      num_array.shift => 1
      num_array => [2, 3, 4]
    
    #unshift - add to the beginning of an array
      num_array.unshift(1) => [1, 2, 3, 4]

    #pop and #shift can also take integer elements that will result in 
    that many elements being removed from the array

  Adding and Subtracting Arrays
    [1, 2, 3] + [3, 4, 5] => [1, 2, 3, 3, 4, 5]

    #concat works the same way:
      a = [1, 2, 3]
      b = [3, 4, 5]

      a + b         #=> [1, 2, 3, 3, 4, 5]
      a.concat(b)   #=> [1, 2, 3, 3, 4, 5]

    Subtracting arrays will remove any elements from the first array that 
    appear in the second:
      [1, 1, 1, 2, 2, 3, 4] - [1, 4]  #=> [2, 2, 3]

  Basic Array Methods
    num_array.methods => gives a very long list of available methods

    Method examples:
      [].empty?               #=> true
      [[]].empty?             #=> false
      [1, 2].empty?           #=> false

      [1, 2, 3, 4].first      #=> 1
      [1, 2, 3, 4].last       #=> 4

      a = [1, 2, [3, 4], [5, 6, 7]]
      a.last.delete(a.last.first) #=> 5
      a                       #=> [1, 2, [3, 4], [6, 7]]

      [1, 2, 3].length        #=> 3

      [1, 2, 3].reverse       #=> [3, 2, 1]

      [1, 2, 3].include?(3)   #=> true
      [1, 2, 3].include?("3") #=> false

      [1, 2, 3].join          #=> "123"
      [1, 2, 3].join("-")     #=> "1-2-3"

      #sort - sorts the array, not destructive (errors if comparing 
      differing data types like an array with a number)
      a = [5, 3, 8, 2, 4, 1]  #=> [5, 3, 8, 2, 4, 1]
      a.sort                  #=> [1, 2, 3, 4, 5, 8]

      #product - combine two arrays by returning an array that is a 
      combination of all elements from all arrays
      [1, 2, 3].product([4, 5]) 
      #=> [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]

      a = [1, 2, [3, 4, 5], [6, 7]]   #=> [1, 2, [3, 4, 5], [6, 7]]
      a.flatten                       #=> [1, 2, 3, 4, 5, 6, 7]
      #flatten is not destructive

      #delete_at() - permanently removes the array element at the index 
      that is inputted

      #delete - if you don't know the index of the value you want to 
      delete, you can use the delete method to remove any instances of the
      provided value from an array

      #uniq - iterates through an array and deletes any duplicate elements
        myArray = [1, 1, 2, 3, 4, 4]
        myArray.bang! => [1, 2, 3, 4]
        myArray => [1, 1, 2, 3, 4, 4]

        This is not a destructive method, but you can make it one by 
        adding a bang suffix (!) to the method:
          myArray = [1, 1, 2, 3, 4, 4]
          myArray.bang! => [1, 2, 3, 4]
          myArray => [1, 2, 3, 4]

      #select - iterate over an array and return a new array that only 
      contains elements that return true to the provided expression
        numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
          => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        numbers.select { |number| number > 4 }
          => [5, 6, 7, 8, 9, 10]
        numbers
          => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

      #to_s - returns a string representation of an array (not destructive)

      Methods that use blocks
        Blocks
          Can be passed using the 'do...end' syntax
            example using #each:
              array = [1, 2, 3, 4, 5]
              array.each do |element|
                puts "The element is #{element}"
              end
            
          Also passed using curly braces '{}'
            array.each_index { |i| puts "This is index #{i}" }
              |i| - this is the block parameter
              the next part is the block of code that gets executed for 
              each index

            Here's an example using #map:
              array = [1, 2, 3, 4, 5]
              doubled_array = array.map { |element| element * 2 }

              puts doubled_array => [2, 4, 6, 8, 10]

        #each_index - iterates through an array like #each but the 
        variable represents the index of the element as opposed to the 
        value. 

        #each_with_index - can use value and index as block parameters
          arr.each_with_index{|value, index| puts "#{value}, #{index}"}

        #map - invokes the given block once for each element in the 
        collection, creates and returns a new array containing the values 
        returned by the block

        #map vs #each
          #each example:
            a = [1, 2, 3]
            a.each { |e| puts e + 2 }
            3
            4
            5
            => [1, 2, 3]

          #map example:
          a = [1, 2, 3]
          a.map { |x| puts x**2 }
          1
          4
          9
          => [nil, nil, nil]
          
          puts will always return nil when the block is invoked, which 
          makes up the values in the newly created array.

        Overall Rule: use each for iteration and map for transformation.



  Comparing Arrays 
    == operator - compare arrays for equality

Hashes
  Similar to objects in JS

  Hashes are like arrays (collection of values) that are indexed by key 
  rather than index. The two main advantages of this are 1. being able to 
  select the value you want without figuring out the numerical index, and 
  2. values stored in hashes don't need to be stored in any particular 
  order.

  Hashes vs Arrays
    When deciding whether to use a hash or an array, ask yourself a few questions:
      Does this data need to be associated with a specific label? If yes, 
      use a hash. If the data doesn't have a natural label, then typically 
      an array will work fine.

      Does order matter? If yes, then use an array. As of Ruby 1.9, hashes
      also maintain order, but usually ordered items are stored in an 
      array.

      Do I need a "stack" or a "queue" structure? Arrays are good at 
      mimicking simple "first-in-first-out" queues, or "last-in-first-out" 
      stacks.

  Creating Hashes
    Hash literal - "{}" curly braces
      Ex: 
        my_hash = {
          "a random word" => "ahoy",
          "Dorothy's math test score" => 94,
          "an array" => [1, 2, 3],
          "an empty hash within a hash" => {}
        }

      key => value (=> is called a hash rocket)

    ::new method 
      my_hash = Hash.new
      my_hash               #=> {}

  Accessing Hash Values 
    Syntax is very similar to indexing arrays:
      shoes = {
        "summer" => "sandals",
        "winter" => "boots"
      }

      shoes["summer"]   #=> "sandals"

    Attempting to access a key that doesn't exist will return nil:
      shoes["hiking"]   #=> nil

      If you need to return an error when the key does not exist, you can
      use the fetch method:
        shoes.fetch("hiking")   #=> KeyError: key not found: "hiking"

        This method can also be given a default value to return instead of
        an error:
          shoes.fetch("hiking", "hiking boots") #=> "hiking boots"

  Adding and Changing Data
    Can add data the same as you would to an array:
      shoes["fall"] = "sneakers"

      Can also change the values of existing keys this way:

  Removing Data
    #delete - shoes.delete("fall")    #=> "sneakers"

  Methods
    Hashes and arrays both employ Ruby's Enumerable module, not sure what
    this means but it leads to them both responding to many of the same 
    methods

    Methods specific to hashes:
      #keys - returns array of the keys from a hash

      #values - returns array of the values from a hash

      #key? - allows you to check if a hash contains a specific key,
      returns a boolean

      #select - pass it a block and it will return any key-value pairs 
      that evalutate to true
        name_and_age = { "Bob" => 42, "Steve" => 31, "Joe" => 19}
        name_and_age.select { |k,v| k == "Bob" }  
        => {"Bob"=>42}
        name_and_age.select { |k,v| (k == "Bob") || (v == 19) }
        => {"Bob"=>42, "Joe"=>19}

      #fetch - defined above

      #to_a - returns a nested array version of your hash, not destructive
        name_and_age.to_a
        => [["Bob", 42], ["Steve", 31], ["Joe", 19]]
        name_and_age
        => {"Bob"=>42, "Steve"=>31, "Joe"=>19}


  Merging Two Hashes
    #merge - merges two hashes, any duplicate keys will take on the value
    of the hash getting merged in (hash2 in this case)
      hash1.merge(hash2)

  Symbols as Hash keys
    symbols are commonly used as hash keys due to simplified syntax when 
    defining hash literals:
      # 'Rocket' syntax
      american_cars = {
        :chevrolet => "Corvette",
        :ford => "Mustang",
        :dodge => "Ram"
      }
      # 'Symbols' syntax      *ONLY WORKS FOR SYMBOLS*
      japanese_cars = {
        honda: "Accord",
        toyota: "Corolla",
        nissan: "Altima"
      }
    
    When you use symbols as keys you also obviously have to use a symbol 
    to access it's value:
      american_cars[:ford]    #=> "Mustang"
      japanese_cars[:honda]   #=> "Accord"

  Iterating over Hashes 
    Ex:
      person = {name: 'bob', height: '6 ft', weight: '160 lbs', hair: 
      'brown'}

      person.each do |key, value|
        puts "Bob's #{key} is #{value}"
      end

      Output:
        Bob's name is bob
        Bob's height is 6 ft
        Bob's weight is 160 lbs
        Bob's hair is brown

Methods
  Allow you to name sections of your code that can be called in other 
  places in the program. DRY - Don't repeat yourself
    if you find yourself rewriting sections of code, define it as a 
    method instead and apply it that way.

  In Ruby, methods and functions are essentially interchangable because 
  ruby is purely object-oriented. The difference between functions and 
  methods in other languages is that functions do not have an associated 
  object. 

  One of Ruby's main advantages is the large number of built in methods.

  Creating a Method
    Syntax
      def my_name
        "Joe Smith"
      end

      puts my_name    #=> "Joe Smith"

    Naming Conventions
      snake_case

      Ruby has ~40 reserved words like end, while, for

      ?, !, =, can only go at the end of the name

      Cannot begin the name with a number

      If it feels like the method does too many things to give it a simple
      name, that is generally a sign that it should be broken up into 
      several smaller/simpler methods

  Parameters and Arguments - commonly used interchangably
    Parameters - variables (or placeholder for variables) that your 
    method receives when it is called

    Argument - actual variables that get passed to the method

    Default Parameters:
      def greet(name = "stranger")
        "Hello, " + name + "!"
      end

      puts greet("Jane") #=> Hello, Jane!
      puts greet #=> Hello, stranger!
  
  Optional Parentheses 
    Keep in mind that parentheses are optional when calling methods in 
    Ruby, say("Hi") is the same as say "Hi"

  Ways to call Methods
    1. some_method(obj) - send arguments (obj) to a method call
    2. a_caller.some_method(obj) - a_caller is called an explicit caller

  What methods return
    Implicit return - Methods in Ruby will return the output of the last 
    expression that was evaluated even without the return keyword

    Explicit return - using the return keyword will stop the method from 
    evalutating any further lines. 
      Useful for writing checks for input errors into your methods
        def even_odd(number)
          unless number.is_a? Numeric
            return "A number was not entered."
          end

          if number % 2 == 0
            "That is an even number."
          else
            "That is an odd number."
          end
        end

  Chaining Methods
    ex:
      phrase = ["be", "to", "not", "or", "be", "to"]

      puts phrase.reverse.join(" ").capitalize
      #=> "To be or not to be"

    You can also directly pass method calls as arguments to other methods.
    That's kinda what's happening here but this is an example of what it 
    looks like to pass the results of multiple methods to another:
      multiply(add(20, 45), subtract(80, 10))
      => 4550             *these aren't native methods*

  Predictate Methods - methods that return a boolean
    Usually denoted with a "?" at the end of the method name (not 
    enforced)

  Bang Methods - simultaneously perform their action and overwrite the 
  value of the original object with the result
    Dentoed with a "!" at the end of the method name

    Writing 
      string.downcase! 
    is the equivalent of writing 
      string = whisper.downcase

Debugging 
  p vs puts
    puts is good for debugging, but the drawback is that anything that 
    evaluates to nil or an empty string will just print a blank line to 
    the terminal

    Using p is the solution to this problem

  Pry Gem
    Pry is a Ruby Gem that lets you open an IRB-like session in your 
    terminal while your program is running. 

    To use, you have to include: require 'pry-byebug' at the top of your
    program

    Then the Pry-byebug will open whenever you call binding.pry in the 
    program.

    Once Pry is open, you can enter 'next' to step over to the next line

  Debug Gem
    Launch without configuration
      Without any configuration, you can use this debugger by 
      "Start Debugging" (F5 key) if you activate .rb file.

      You will see the "Debug command line" input dialog. Please specify 
      your favorite command line you want to debug.

      For example:

      ruby foo.rb (launch foo.rb)
      ruby foo.rb 10 20 30 (launch foo.rb with options 10, 20 and 30)
      rake taskA (launch rake task taskA)
      bundle exec rspec (launch rspec command with bundle exec)
      bin/rails s (launch bin/rails s)
      When you select a command line, the specified command will run on 
      rdbg debugger, and VSCode will connect to the rdbg debugger with 
      UNIX domain socket.

      And new terminal is created (named rdbg). You can see stdout/err 
      outputs and you can input stdin on rdbg terminal.

      You can stop the programs
      - by setting breakpoints (F9) on source code.
      - by exception (if you enable "rescue exception").
      - by pushing the Pause button (F6).
      
      When the program stops, you can see "Call stack", "Variables" and 
      you can set "Watch" expressions. On the debug console, you can input 
      valid Ruby program and you will get an evaluation result on selected 
      context ("Call stack").
  



      

    



    





  
    

  


Using with HTML
    Embed js in html like this: (inside <body>)
        <script>
            //JS goes here
            console.log("Hello, World!")
        </script>
        
    or like this: (inside <body>)
        <script src="javascript.js">//can also do this</script>

Variables
    You can now declare variables in three ways:
        var: traditional way, now replaced by let
        let: same as var but adapted to modern JS, most commonly used
        const: lets you declare a constant (non-changing) variable
    
Numbers
    Arithmetic operators in JS 
        +, -, *, ** (exponent), /, % (modulus), ++ (increment), 
        --(decrement)
            increment/decrement can only be applied to variables
                let num = 3;
                num++; (returns 3, but applies +1)
                num; (returns 4)

                let num = 3;
                ++num; (returns 4)

        There are also assignment operators:
            += num; (shortcut for x = x + num;)
            -= num; (shortcut for x = x - num;)
            *= num; (shortcut for x = x * num;)
            /= num: (shortcut for x = x / num;)
            these are most common ones but there are more

            You can use variables on both sides of the assignment operator
                let x = 3;
                let y = 4;
                x *= y; x now contains 12

        Comparison operators
            === | strict equality (compares value and datatype)
            == | equality (compares value only)
            !== | strict inequality
            != | inequality
            <, >, <=, >=
            All return booleans

        Bitwise operators
            AND (&)
            OR (|)
            XOR (^)
            NOT (~)
            LEFT SHIFT (<<)
            RIGHT SHIFT (>>)
            ZERO-FILL RIGHT SHIFT (>>>)
            
        Comma operator
            commas can be used to evalute multiple expressions on one line
            ex: 
                for (a = 1, b = 3, c = a * b; a < 10; a++) {
                    ...
                }

        + can also be used as unary operator to change datatype to Number
            alert(+true); = 1, alert(+""); = 0
            (does the same thing as Number())
            has the highest priority for order of operations

    Numbers can be written with: 
        decimals
        exponent notation (123e4 = 1230000)

    JS does not have multiple definitions for numbers based on size
    (like other languages may have integers, short, long, double)
        Instead always uses 64-bit floating position
            value: bits 0-51 | exponent: bits 52-62 | sign: bit 63

        integers are accurate up to 15 digits, then rounded
        maximum # of decimals is 17

        floating point arithmetic can lead to slight inaccuracies
        (let x = 0.2 + 0.1; -> x = 0.30000000000000004) you can 
        correct this by multiplying and dividing again: 
        (let x = (0.2 * 10 + 0.1 * 10) / 10; -> x = 0.3)

        The + operator is also used for concatenation in js
        If you add a number and a string, it will result in string
        concatenation: 10 + "20" = "1020";
            Common mistake:
                let x = 10;
                let y = 20;
                let z = "The result is: " + x + y;
                (You may expect this to = "The result is: 30" but
                it will be "The result is: 1020")

            Another note:
                It depends on the order of the operations so this 
                (10 + 20 + "30") will = "3030"

        JS will convert strings to numbers in all numeric operations:
        "100" / "10" will = 10 (but this will not work with +)

        Also Number("100") will return 100 with type Number
        ex: "100" + 3 = 1003 but Number("100") + 3 = 103

        NaN = Not a Number | this will result from trying to do 
        arithmetic with non-numeric strings.
            If NaN is used in a mathematical operation, the result
            will also be NaN.
                
            typeof NaN returns number still
            
        Infinity (or -Infinity) is a number too
            Returns if you calculate a number outside the largest
            possible in js.

            Division by 0 = Infinity too

        Hexadecimal numbers can be used as well.
            JS interprets numeric constants as hexadecimal if they are
            preceded by 0x (eg. let x = 0xFF)

        myNumber.toString(base) can be used to convert/output numbers from
         base 2 to 36:
            Decimal 32 =
                Hexatrigesimal (base 36): w
                Duotrigesimal (base 32): 10
                Hexadecimal (base 16): 20
                Duodecimal (base 12): 28
                Decimal (base 10): 32
                Octal (base 8): 40
                Binary (base 2): 100000

        Order of operations is followed as normal in JS (PEMDAS)

Data Types 
    Variables can store any datatype, a variable containing a string can
    subsequently be assigned to contain a string
        this is called a "dynamically typed" coding language

    Number
        Integers and floating point numbers

        There are also special numeric values 
            Infinity (and -Infinity)
            NaN

    BigInt
        Number cannot contain integers great than 2**53 - 1 (or less than
        -(2**53-1))
            It can actually store larger integers but any larger than the
            value stated above will result in precision errors

        BigInt was added to handle large integers 
            const bigInt = 129194871984721929847198274918721874n;
            Note the "n" at the end of the integer, this creates a BigInt

    String 
        There is practically no difference between "" and '' in JS
            You should pick and stick to one. But having both in JS lets
            you have strings with " and ' inside as long as you use the
            other one to contain the string.
                ex: "I'm using an apostrophe" will work fine
                ex: so will 'Quote: "quote"'

        Backticks (``) are used to create strings with embeded variables
        or expressions: `the result is ${1 + 2}` = "the result is 3"
            Called a template literal

            Template literals can also be used to concatenate strings:
                const one = "Hello, ";
                const two = "how are you?";
                const joined = `${one}${two}`; -> "Hello, how are you?"

                You can also concatenate numbers with strings this way

            Template literals respect line breaks so you can write 
            multi-line strings this way. (you can do this in normal
            strings using the line break character: \n)

        Escape characters
            if you want something to be recognized as text rather than
            part of the code, you can use an escape character (\)
            ex: 'I\'m using an apostrophe for both'

        toString() - like Number() but converts to string

        String Methods 
            length: text.length;
                returns length of string

            Extracting String Parts
                slice(start, end)
                    extracts from start to end (JS indexes from 0)

                    slice(8) will extract everything from 8 to the end

                    slice(-12) extracts the last 12 characters

                substring(start, end)
                    This is identical to slice but it will not take 
                    negative inputs (treated as 0).
                
                substr(start, length)
                    Also similar to slice but takes start and length as
                    inputs.

            Replacing String Content
                text.replace(searchKey, newText)
                    This will replace the FIRST instance of searchKey
                    inside text with newText.

                    Note: this returns a new string and does not modify 
                    the original string `text` in this case

                    Replace is case sensitive by default
                        You can change this using an /i flag (insensitive)
                            text.replace(/searchKey/i, newText)

                    You can use a /g flag to replace all matches:
                        text.replace(/searchKey/g, newText)
                    
            Converting to upper/lower case
                text.toUpperCase()
                text.toLowerCase()

            Concatentation
                text1.concat(" ", text2) will combine text1 and text2 with
                a space in between.

            Trim
                text1.trim() removes the whitespace (spaces) from both
                sides of a string.

                text1.trimStart() only removes whitespace before string

                text1.trimEnd() only removes whitespace after string

            Padding
                text.padStart(num, " ") adds num characters of " " before
                string.

                text.padEnd(num, " ") adds to the end

            Extracting String Characters 
                text.charAt(0); returns first character in text

                text.charCodeAt(0); returns UTF-16 of first character

                You can also index strings like arrays, but this can lead
                to unpredictable results, it is also read only
                    let char = text[0];
                
            Converting to an Array 
                text.split(",") creates an array of text's elements after
                splitting on commas

    Boolean 
        true/false

        all comparisons return booleans

        Falsy vs truthy
            A number 0, an empty string "", null, undefined, and NaN all 
            become false. Because of that they are called “falsy” values.

            Other values become true, so they are called “truthy”.

    Null
        null is its own type of value.

    undefined
        undefined also has a type of its own.

        undefined = "value not assigned"

        let age, alert(age); returns "undefined"

    Objects and Symbols
        Objects can store collections of data, unlike the previous data 
        types which can only store single values.

        The symbol type is used to create unique identifiers for Objects

    You can use the typeof operator to return the type of the operand
        typeof 0 -> number, typeof "" -> string, typeof alert -> function

        typeof null will return object (this is an error but is kept for
        compatibility)

Operators/Comparisons
    Comparing Strings 
        Strings are compared by looking at individual characters, for
        string1 > string2, if the first character in string1 is greater
        than the first character in string2, this will return true.
        If the first characters are the same, it will move on to the
        second character in both strings. If the strings are the same up 
        until a certain length, the longer string is greater.

        Note: 'A' < 'a' = true (unicode order)

    In comparisons of values with different types, JS will convert all to
    numbers. true -> 1, '2' -> 2, '01' -> 1, false -> 0

    Strict vs non strict equality operators
        use === if you need to distinguish between 0/''/'0' and false

    Notes:
        null == 0 -> false, but null >= 0 -> true 
        this is because >= converts null to 0 but == does not

        undefined == null -> true 

        Lesson: don't use comparisons when the operand may be undefined or
        null. And use === when looking at equalities

Conditional Statements
    if/elseif/else Statements
        if (condition) {
            //code block, executed if condition is true
        } elseif (condition2) {
            //code block, executed if condition is false AND condition2 is
            true
        } else {
            //code block, executed if condition is false AND condition2 is
            false
        }

        note: else is not necessary, you can remove it from the code block
        above and it will run the same way.

    logical operators: AND (&&), OR (||), NOT (!)

    switch Statements
        switch (expression) {
            case choice1:
                // code
                break;

            case choice2:
                // code
                break;

            default:
                //run this code if no case matches
        }

        If you have many cases that should run the same code, you can
        stack the case declarations:
            case 0:
            case 1:
            case 2:
                // 0, 1, and 2 will run this code

    Ternary operator
        pseudocode: condition ? run this code : run this code instead

        ex:
            condition
              ?  run this code if true
              :  run this code if false;
    
    Alternatives to if Statements
        if (age > 18) {
            return true;
        } else {
            return confirm('Did parents allow you?');
        }

        question operator: return (age > 18) ? true : confirm('Did parents
        allow you?');

        or operator: return (age > 18) || confirm('Did parents allow 
        you?');

Functions
    Default Parameters
        If you're creating a function and want to make use of an optional
        parameter you can set a default value like this:
            function hello(name = 'Chris') {
                console.log(name);
            }
                hello('Devin') -> Devin
                hello() -> Chris

        You can also specify another function as the default parameter, 
        meaning another function will be called when that parameter is not
        specified in the original function call. 
            function hello(name = goodbye()) {
                console.log(name);
            }
                hello('Devin') -> Devin
                hello() -> goodbye()
        If you want to assign a default parameter later on in the function
        body, you can do that in two ways: 
            1. if (input == undefined){input = <default>;}

            2. input = input || <default>;

    Anonymous Functions
        For example, say you are using an event listener to run some code
        when the user types into a text box. This uses addEventListener(),
        which expects two parameters: event to listen for, and function to
        run when the event is observed. 

        Before: 
            function logKey(event) {
                console.log(`You pressed "${event.key}".`);
            }
            textBox.addEventListener('keydown', logKey);

        Now: 
            textBox.addEventListener('keydown', function(event) {
                console.log(`You pressed "${event.key}".`);
            });
    
    Arrow Functions
        If you're passing an anonymous function like this that only has
        one line, you can instead use an arrowhead function.

        Ex:
            textBox.addEventListener('keydown', (event) => console.log
            (`You pressed "${event.key}".`));

    Scope
        Scope is used for security concerns as well as organization. It
        allows you to call external functions without potential
        overlapping of variable names. 

        Function Scope
            When you create a function, the variables and other things 
            defined inside that function are inside their own scope. This
            means they are inside their separate compartment and will not
            be accessible by code outside that function. They can, 
            however, be used if they are outputted by the function. These
            variables are called inner variables.
        
        Global Scope
            Anything defined in this top level outside all the functions
            is called the global scope and can be accessed from anywhere 
            else in the code. These variables are called outer variables.

            Note: Inner variables will override outer variables if a
            function that has an inner variable with the same name is
            called. Calls made to this variable before the function is
            called will still use the outer variable.
                Subnote: This only happens if the function directly calls
                the outer variable. If you have let variable = 1; outside
                the function, then have let variable = 2; inside the 
                function, the outer variable will not be affected.

    Function Syntax
        Creating a function
            function <functionName>(<paramater>)

        Calling a function
            <functionName>(<argument>)

    Returning a value
        If you use `return` without a value, it will exit the function

        A function that returns nothing is the same as if it returned
        undefined. alert(function(){empty} === undefined); //true

        If you want your return statement to span multiple lines you must
        put the statement inside paranthesis:
            return (
                long expression
            )

    Naming Functions
        Functions are typically named with a short verbal prefix to 
        quickly and briefly explain what the function does:
            get_, calc_, create_, check_, show_

        Functions should do what they are named to do and nothing else. It
        is better to have many helper functions than one large function
        with everything included
            This lets you write what is essentially pseudocode at first 
            while naming all of the other functions you need to reach
            your end goal. Then you can go back and construct all of the
            necessary helper functions.

            Helper functions also basically serve as comments when you 
            contruct your functions this way.

Javascript Call Stack 
    This is the system javascript uses to keep track of its place when
    executing functions that invoke other functions. 

    Follows the Last In, First Out principle
        When a function is called, it goes to the top of the stack, the 
        highest up functions are completed first, but if another function
        is called within this one, it must complete that function first.

    The call stack has a set size and will result in a stack overflow 
    error when too many calls are made. This happens most frequently due
    to recursive functions with no exit condition, or an exit condition 
    that is never met.

    Javascript is single threaded, meaning it only operates on one call 
    stack at a time.

    Asynchronous javascript is used to execute tasks while waiting for 
    another task to be completed, this can be used for things like loading
    a spinner while a page is gathering information.

For Loop Syntax
    for (let i=0; i <= max; i++){
        console.log(i); //prints from 0 to max
    }

Errors 
    General Error Types
        Syntax errors - usually from spelling errors, will almost always
        throw an error that makes it easy to fix.

        Logic errors - not as easy to catch, errors with your code's logic
        may not throw any actual errors, instead just resulting in
        incorrect outputs. Requires debugging and stepping through code to
        find the error and fix it.

    Error example
        Uncaught ReferenceError: c is not defined
            at <anonymous>:1:13

        ReferenceError - type of error
            In this case, the message is `c is not defined`
                This is because I attempted to reference variable `c` 
                without defining it.

            There are other messages you can get for ReferenceError
                ex: ReferenceError: can't access lexical declaration 'X' 
                before initialization

        at <anonymous>:1:13
            This is the location of the error, formatted as:
                at <fileName>:[line]:[character]
        
        Stack Trace 
            ex: Uncaught ReferenceError: c is not defined
                    at add (<anonymous>:5:3)
                    at print (<anonymous>:9:3)
                    at <anonymous>:12:1

            This tells us that c is not defined in scope of add(), which
            was called by print(), which was called on line 12
        
        Common Error Types
            SyntaxError - code is not written correctly

            ReferenceError - referencing something that does not exisit
                usually from spelling error or changed variable name
            
            TypeError - thrown from many variable type related errors
                - an operand or argument passed to a function is 
                incompatible with the type expected by that operator or 
                function
                - when attempting to modify a value that cannot be changed
                - when attempting to use a value in an inappropriate way

JavaScript Components (arrays, loops)
    Arrays 
        const array_name = [item1, item2, ...];   
            If you declare with an array with const, you can add values to
            the end of the array using array_name.push(item3);. But you 
            cannot reassign values like this: array_name = [itemA, itemB];

            In order to do that, you need to declare the array with let.

        You can also declare arrays this way:
            const array_name = new Array("item1", "item2", "item3");

        Arrays are indexed from 0 with brackets:
            console.log(array_name[1]); // "item2"

            You can also change values by setting the index = new value:
                array_name[0] = "itemA";
                
                Be careful setting values at high indicies, you will
                create undefined "holes" in arrays if you assign a 
                value at an index greater than array.length
            
        console.log(typeof myArray); // object
            Arrays are objects but they're kind of in their own class.

            Arrays are basically objects that use numbers instead of names
            to access its content.

            Array Format:
                const person = ["John", "Doe", 46];

            Object Format: 
                const person = {firstName:"John", lastName:"Doe", age:46};

        You can store objects in arrays, you can also store other arrays 
        and functions as well.

        Array Properties/Methods
            array_name.length // returns number of elements
                you can access last array element with [array.length - 1]
            
            array_name.sort() // sorts array

            .forEach - can use this instead of a for loop
                const fruits = ["Banana", "Orange", "Apple", "Mango"];

                let text = "<ul>";
                fruits.forEach(myFunction);
                text += "</ul>";

                function myFunction(value) {
                text += "<li>" + value + "</li>";
                }
            
            .push() - add element to array (also returns new array length)
                can also add like this:
                    array_name[array_name.length] = "item"

            .pop() - remove last element from array (also returns this 
            value)

            .shift() - same as pop() but removes first array element

            .unshift() - same as push() but adds to the beginning of array

            .slice(start_index, stop_index) - selects elements from array
            from start_index UP TO stop_index (value at stop_index NOT 
            included)
                The slice method doesn't affect the original array, just
                creates a new array with the selected elements

            .splice(indexToStartFrom, numOfElementsToRemove, item1, item2)
                so .splice(2, 0, item1, item2) would remove 0 items and 
                add item1 and item2 at index 2 and index 3, shifting the
                other elements down

                splice changes the existing array directly and returns an
                array with the deleted elements (if any).

                you can also just remove elements with splice() similar to
                shift. .splice(0, 1) will just remove the first value

            .toString() - converts array to a comma-separated list

            .join(", ") - does the same thing but lets you specify the 
            separator

            .concat - let newArray = array1.concat(array2); 
                does not change existing array, creates a new one
                
                concat() can take any number of array arguments

                it can also take strings and function similarly to push()

    Loops 
        Tasks loops are good for:
            Repetetive tasks - ex: draw 100 cirlces

            looping through a collection (for...of loop)
                const myArray = ["one", "two", "three"];

                for (const item of myArray) {
                    console.log(item);
                }

                //output: one; two; three;

        map() - run code on each item of a collection and create new 
        collection with the changed items
            ex:
            function toUpper(string) {
                return string.toUpperCase();
            }

            const cats = ['Leopard', 'Serval', 'Jaguar', 'Tiger', 'Caracal', 'Lion'];

            const upperCats = cats.map(toUpper);

            console.log(upperCats);
            // [ "LEOPARD", "SERVAL", "JAGUAR", "TIGER", "CARACAL", "LION" ]

        filter() - similar to map() but creates a new collection with all
        items that match the criteria.
            function lCat(cat) {
                return cat.startsWith('L');
            }

            const cats = ['Leopard', 'Serval', 'Jaguar', 'Tiger', 'Caracal', 'Lion'];

            const filtered = cats.filter(lCat);

            console.log(filtered);
            // [ "Leopard", "Lion" ]
        
            same example with function expression:
                const cats = ['Leopard', 'Serval', 'Jaguar', 'Tiger', 'Caracal', 'Lion'];

                const filtered = cats.filter((cat) => cat.startsWith('L'));
                console.log(filtered);
                // [ "Leopard", "Lion" ]

        Break statement
            If you want to exit a loop before all iterations are complete,
            you can exit with `break;`

            Usually these will be contained within if/switch statements 
            that will break out of the loop when those conditions are 
            met.

        Continue statement
            similar to break except it will just skip to the next 
            iteration. 

        While loop 
            syntax:
                while (condition) {
                    //code to run
                }

            do...while loop syntax:
                do {
                    //code to run 
                } while (condition)

            While loops are much easier to accidentally create infinite
            loops. Always need to make sure you increment (or decrement)
            the initializer

        What loop should you use?
            1. Need access to index/counter number -> for, while, or 
            do...while
            2. Don't need access to index/counter number -> for...of
                using this method when you don't need to use the index of 
                the object element is always preferred, helps limit 
                potential for errors like not incrementing the counter or 
                not initializing from 0.

Test Driven Development
    A good practice in the dev world is to first write automated tests for
    your programs before writing the actual program. The tests should use
    the function and see if it outputs the correct value. 

DOM Manipulation and Events 
    DOM - Document Object Model 
        Tree-like representation of the contents of a webpage.

        Tree of "nodes" with different relationships depending on how they
        are arranged in the HTMl document.

        You can think of it like a bunch of divs in an HTML document with
        parnet, child, and sibling relationships.

        HTML code is converted to the DOM when it is parsed by a web 
        browser. The nodes have many properties and methods attached that
        we can use with javascript.

    Targeting Nodes with Selectors
        Review CSS-notes.txt for this, but there are a number of different
        ways you can use CSS to reference nodes.

    DOM Methods
        Query Selectors
            element.querySelector(selector) - returns a reference to 
            the first match of selector

            element.querySelectorAll(selectors) - returns a "nodelist" of
            references to all matches of the selectors
                This "nodelist" resembles an array but it is not one. 
                Mostly important because it is missing many array methods.
                
                You can convert a nodelist to an array using Array.from()
        
        Element Creation 
            document.createElement(tagName, [options])
                ex: const div = document.createElement('div');

                Creates a new element with tag `tagName`, [options] gives 
                you some optional parameters to worry about later.

                This DOES NOT place the element in the DOM, just creates 
                it in memory. See appending below

        Append Elements
            parentNode.appendChild(childNode)
                Appends childNode as the last child of parentNode
            
            parentNode.insertBefore(newNode, referenceNode)
                Inserts newNode into parentNode before referenceNode.

        Remove Elements
            parentNode.removeChild(child)
                Removes child from parentNode on the DOM and returns a 
                reference to child.
            
        Altering Elements
            You can make many changes to an element once you have a 
            reference to it.

            Getting a reference: 
                const div = document.querySelector('.className');

                const div = document.createElement('div');                     
                // creates a new div referenced in the variable 'div'
            
            Adding Inline Style
                div.style.color = 'blue';

                div.style.cssText = 'color: blue; background: white;';

                div.setAttribute('style', 'color: blue; background: white;');

                Note: 'background-color' (with a hyphen) is how CSS labels
                its attributes, but you have to use camelCase to access 
                CSS attributes. You can also use bracket notation instead 
                of dot notation.
                    Doesn't work: div.style.background-color
                    Does work: div.style.backgroundColor
                    Does work: div.style.['background-color']
                    Does work: div.style.cssText = "background-color: white;" 
                
            Editing Attributes 
                div.setAttribute('id', 'theDiv');                              
                // if id exists, update it to 'theDiv', else create an id
                // with value "theDiv"

                div.getAttribute('id');                                        
                // returns value of specified attribute, in this case
                // "theDiv"

                div.removeAttribute('id');                                     
                // removes specified attribute

            Working with Classes
                div.classList.add('new');                                      
                // adds class "new" to your new div

                div.classList.remove('new');                                   
                // removes "new" class from div

                div.classList.toggle('active');                                
                // if div doesn't have class "active" then add it, or if
                // it does, then remove it

                Note: It is generally cleaner/preferred to toggle a CSS 
                class rather than adding/removing inline CSS
            
            Adding Text Content
                div.textContent = 'Hello World!'                               
                // creates a text node containing "Hello World!" and
                // inserts it in div

            Adding HTML Content
                div.innerHTML = '<span>Hello World!</span>';                   
                // renders the HTML inside div

                Note: Using div.textContent is preferred, using innerHTML
                can lead to security risks somehow if misused.
            
            Example:
                <!-- your HTML file: -->
                <body>
                <h1>
                    THE TITLE OF YOUR WEBPAGE
                </h1>
                <div id="container"></div>
                </body>

                // your JavaScript file
                const container = document.querySelector('#container');

                const content = document.createElement('div');
                // create new div, store reference in content variable

                content.classList.add('content');
                // adds class 'content' to new div 

                content.textContent = 'This is the glorious text-content!';
                // adds textContent to new div

                container.appendChild(content);
                // append new div to existing container div

                New DOM Tree:
                <!-- The DOM -->
                <body>
                <h1>
                    THE TITLE OF YOUR WEBPAGE
                </h1>
                <div id="container">
                    <div class="content">
                    This is the glorious text-content!
                    </div>
                </div>
                </body>

                Note: Javascript will not alter your HTML code at all, it
                will only make changes to the DOM

    Adding JS to your HTML
        If you add your JS to your HTML file in the body before the nodes 
        are created in the DOM, none of your DOM manipulation methods will
        work. You can solve this by linking your JS file at the bottom of 
        the HTML body or by linking it in the HTML <head> like this:
            <head>
                <script src="js-file.js" defer></script>
            </head>
            (the `defer` keyword is what tells the browser to load the JS
            file after the HTML is parsed.) 

    Events
        Events are actions that occur on webpages such as mouse-clicks or
        keypresses. We can make the webpage listen and react to these 
        events using JS.

        Three Methods:  1. specify directly on HTML elements
                        2. set properties on the DOM nodes in JS
                        3. Attach event listeners to DOM nodes in JS
            Method 1.
                <button onclick="alert('Hello World')">Click Me</button>

                Not an ideal solution because we clutter the HTML file 
                with javascript. Also limits our usage to one property per 
                DOM element per click which would make things even more 
                messy/complicated.
            
            Method 2.
                <!-- the HTML file -->
                <button id="btn">Click Me</button>

                // the JavaScript file
                const btn = document.querySelector('#btn');
                btn.onclick = () => alert("Hello World");

                This solution is cleaner for the HTML file, but still has 
                the issue of only being able to have one `onclick`
                property.
            
            Method 3. (preferred)
                <!-- the HTML file -->
                <button id="btn">Click Me Too</button>

                // the JavaScript file
                const btn = document.querySelector('#btn');
                btn.addEventListener('click', () => {
                alert("Hello World");
                });

            Summary/example:
                <!-- the HTML file -->
                <!-- METHOD 1 -->
                <button onclick="alertFunction()">CLICK ME BABY</button>

                // the JavaScript file
                function alertFunction() {
                alert("YAY! YOU DID IT!");
                }

                // METHOD 2
                btn.onclick = alertFunction;

                // METHOD 3
                btn.addEventListener('click', alertFunction);
        
        Attaching Listeners to Groups of Nodes
            You can make use of the querySelectorAll() function to get a 
            nodelist which you can iterate through and add event listeners
            to multiple elements that match the selector(s) in the 
            original selection.
                Example:
                HTML
                <div id="container">
                    <button id="1">Click Me</button>
                    <button id="2">Click Me</button>
                    <button id="3">Click Me</button>
                </div>

                Javascript
                // buttons is a node list. It looks and acts much like an array.
                const buttons = document.querySelectorAll('button');

                // we use the .forEach method to iterate through each button
                buttons.forEach((button) => {

                    // and for each one we add a 'click' listener
                    button.addEventListener('click', () => {
                        alert(button.id);
                    });
                });
        
        Other Events you can Listen for
            click, dblclick, keydown, keyup, drag, error, input, invalid, 
            load, mousedown, mouseenter, mouseleave, scroll, wheel, 
            select (many more here 
            https://www.w3schools.com/jsref/dom_obj_event.asp)

        Wes Bos - Event Capture, Propagation, and Bubbling
            Bubbling - when you click on an element, you are also clicking
            on the element that contains that one, and the element that 
            contains the containing element, and the one containing that 
            element, and the HTML tag, and the browser window, etc.
                It registers clicks on elements from the top down. 
                After capturing all of the clicks by bubbling down, it 
                will start triggering events associated with those clicks 
                by bubbling up. (so the deepest cascaded element you click 
                on will have its event triggered first)

            capture: true - this is an option that tells the event 
            listener to trigger its action while bubbling down, instead of
            waiting to bubble back up. (defaults to false)
                ex: 
                divs.forEach(div => div.addEventListener('click', 
                function, {
                    capture: true
                }));

            e.stopPropagation(); - stopPropagation is an event method that
            you can use to tell your event to not bubble up after clicking
            on an element. So this will only trigger events associated 
            with the element you act on directly, and not its containing 
            element(s).
                You can also use this with capture: true to only trigger
                the outer-most containing element.

                Or you can just use an if statement to stop it on the 
                element you want.

            once: true - another useful eventListener option, this will 
            cause the eventListener to remove itself after being clicked
            the first time.
        
    






